<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Syntax and Semantics</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="9983f4ed-f215-4695-bd10-d423acceaa37" class="page sans"><header><h1 class="page-title">Syntax and Semantics</h1><p class="page-description"></p></header><div class="page-body"><nav id="64c8d39e-d783-4a21-9259-3fc0f5136123" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#bb3bd80e-0adb-4f5b-b36c-60cd92a28870">Syntax and Semantics of a PL</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2abf70f8-ab60-4b86-8cf7-ae54f32f2218">Describing the syntax</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e3b03965-08ab-4f37-aabe-cd2fb0e0b9d0">Language Recognizers - Finite Automata</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f50cd8b7-645d-43b7-b869-39dc2d5c0d91">Language Generators - Regex</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#50846b4b-bed8-4678-9a34-5f8264c9930f">Backus Naur Form</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#08c13db3-03a5-4c59-bdb3-698ed8619a20">BNF</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8dd6c348-000c-47d3-8fc6-60f99ef8507f">Grammar and Grammar Derivations</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#874cfbb8-68ee-4ccd-946f-2a0bee1664e5">Context Free Language/Grammar</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9850e347-1628-40a7-bcef-d99f22857f85">LMD and RMD </a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#98ba6c08-3869-42d8-acac-c3c39d1de4aa">Parse Tree</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#92da2915-b165-4e93-8010-a993843f1cc0">Ambiguity</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ed4c9a8d-741d-4104-8d6c-01b382451cb7">Recursive Grammar</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d198fef8-5bbe-4463-904e-9f5d032bdafe">Extended BNF </a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#edf7644b-7ff5-4460-8657-50cd2fd4b144">Grammar and Recognizers</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0834ef55-14a1-4d78-95b6-718a5e21c42a">Example 1</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#97928785-d92c-4844-bc26-0f2fbd59ccab">Example 2</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f7055e27-6e82-4a81-82f4-3e0500b5d401">Attribute Grammars</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#b1e265d6-ce3f-4519-8422-140e3fba069d">Static Semantics</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2b92c224-120d-4280-a9c6-ea4b9e0fafbb">Example for describing a rule</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b8277fe6-b611-47f3-9e7e-f272a69b650c">Attribute Grammar for Simple Assignment Statements</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#14653357-982e-491a-90bd-1fb635dc98ae">Computing the Attribute values</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#b9930dae-1796-4a82-b332-291b376bb56a">Describing the meaning of Programs (Dynamic Semantics)</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1f4e4836-a8d5-48d2-8a13-4334c0635414">Operational Semantics (States)</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b98efc73-1546-40dd-b956-9818c4facc13">Denotational Semantics (Math)</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a2a18eb7-9ab8-452c-bae3-ad8d8ae843be">Axiomatic Semantics (Logical Statements or Axioms)</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#db927056-f562-414d-bb4b-0966478272b2">Sequences</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#dc6f427b-0317-4d6d-a854-92e57119c353">Selection</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#1ad4de07-283d-4439-8a45-c521df4bf8d4">Loops</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#3fdebd6c-5101-4d8e-954a-2dc19faeb9b1">Program Proofs (for checking the correctness)</a></div></nav><h1 id="bb3bd80e-0adb-4f5b-b36c-60cd92a28870" class="">Syntax and Semantics of a PL</h1><ul id="10802f56-6f9a-4afd-b3a2-4506886a1dcc" class="bulleted-list"><li style="list-style-type:disc">Syntax of a programming language is the form of it’s expressions, statements and program units</li></ul><ul id="6c9ea33c-82c3-4533-a6b2-7b936d68f2b0" class="bulleted-list"><li style="list-style-type:disc">Semantics of a programming language is the meaning of those expressions, statements, and program units</li></ul><pre id="a378f1f0-947b-4879-83da-c5fd3b162e87" class="code code-wrap"><code>while(bool_expression){
	statement
}</code></pre><ul id="352eaaa6-ccf6-462c-92eb-da0e0a93be1c" class="bulleted-list"><li style="list-style-type:disc">The above is the syntax while the semantics talk about what is happening here</li></ul><h2 id="2abf70f8-ab60-4b86-8cf7-ae54f32f2218" class="">Describing the syntax</h2><ul id="2ab6ab0c-481f-48a5-b668-f5302870fa63" class="bulleted-list"><li style="list-style-type:disc">Language → set of strings formed over an alphabet → can be natural or artificial</li></ul><ul id="c01cd81e-8601-41bb-a653-ea8740729e11" class="bulleted-list"><li style="list-style-type:disc">Token → Category of it’s lexemes</li></ul><ul id="e28346d7-64a3-4a72-a948-187715ad3f68" class="bulleted-list"><li style="list-style-type:disc">Lexeme → lower level of syntactic units</li></ul><ul id="af5169bc-5d56-41de-b418-581bef8e4bae" class="bulleted-list"><li style="list-style-type:disc">Alphabet → Set of symbols</li></ul><ul id="48d1fdea-8728-4e0e-a77c-191a07055d2d" class="bulleted-list"><li style="list-style-type:disc"><code>int sum = 40;</code> → here int, sum, =, 40, ; are called lexemes</li></ul><ul id="48ca1c0d-ae66-44d8-82b1-162f19501660" class="bulleted-list"><li style="list-style-type:disc">For artificial languages, lexemes and organization of these words should be correct</li></ul><ul id="0ab86aab-295b-423d-90dd-e7649b45cc15" class="bulleted-list"><li style="list-style-type:disc"><code>index = 2 * count + 17;</code> → (Lexeme: Token)</li></ul><table id="e8a15f42-625b-4a4a-917c-533061f5007d" class="simple-table"><tbody><tr id="c16be8f7-4dbf-4d65-9fd6-eb54dfa74c8e"><td id="Vb`W" class=""><span style="border-bottom:0.05em solid"><strong>Lexeme</strong></span></td><td id="LG;o" class=""><span style="border-bottom:0.05em solid"><strong>Token</strong></span></td></tr><tr id="b37f7fcc-19e0-43c7-b70b-f0348eb96750"><td id="Vb`W" class="">index</td><td id="LG;o" class="">identifier</td></tr><tr id="e8034a04-99a6-4946-9a6d-d71c5f77ea6e"><td id="Vb`W" class="">= </td><td id="LG;o" class="">equal</td></tr><tr id="062cf530-9a78-48a0-911b-8ffece800f80"><td id="Vb`W" class="">2</td><td id="LG;o" class="">int_literal</td></tr><tr id="aa79a041-2fbb-45b5-a7d8-dc28a8580bda"><td id="Vb`W" class="">*</td><td id="LG;o" class="">mult_op</td></tr><tr id="841dd9de-42ae-4512-8efd-6d19fde8c93b"><td id="Vb`W" class="">count</td><td id="LG;o" class="">identifier</td></tr><tr id="673af92a-b202-4e01-b224-b99a69ea1d3b"><td id="Vb`W" class="">+</td><td id="LG;o" class="">plus_op</td></tr><tr id="39d27a15-09c3-43d8-8ad3-c4b2c2246c2f"><td id="Vb`W" class="">17</td><td id="LG;o" class="">int_literal</td></tr><tr id="bb71c64a-94c2-4a60-9695-ff64c218a028"><td id="Vb`W" class="">;</td><td id="LG;o" class="">semicolon</td></tr></tbody></table><h2 id="e3b03965-08ab-4f37-aabe-cd2fb0e0b9d0" class="">Language Recognizers - Finite Automata</h2><ul id="2d9cf672-1f2e-4bec-8b65-837f7259b3b2" class="bulleted-list"><li style="list-style-type:disc">Language is formally defined in two ways, Language Recognizer, Language Generator</li></ul><ul id="5fd66560-84be-4b02-966b-a5358c424a07" class="bulleted-list"><li style="list-style-type:disc">Language Recognizer R is a device which tells a string/sentence is in L or not. It is not meant for enumerating strings of that language where L is the language and sigma is the alphabet<ul id="efee9af1-e3ed-41fa-b07f-31f275c8ee20" class="bulleted-list"><li style="list-style-type:circle">Syntax analysis step in compilation has a recognizer for the language it is translating<ul id="457c734e-41f7-4315-81d9-3d4a703eb8b3" class="bulleted-list"><li style="list-style-type:square">Finite automata used to validate tokens and lexemes</li></ul><ul id="a62c93dd-a1eb-4e79-a231-1091df74c028" class="bulleted-list"><li style="list-style-type:square">After this we don’t use finite automata again</li></ul></li></ul></li></ul><ul id="212b4bbc-a857-48c8-9f8a-08a374aedb9c" class="bulleted-list"><li style="list-style-type:disc">Not meant for enumerating strings of that language</li></ul><ul id="82d8bcc4-d43f-4fa3-b8c6-0c9c9c324ef7" class="bulleted-list"><li style="list-style-type:disc">Hence, a syntax analyzer determines whether the given programs are syntactically correct or not</li></ul><ul id="b0a9950f-10d3-4934-8202-f05f65cd2732" class="bulleted-list"><li style="list-style-type:disc">NOTE: Context Free Languages → Context Free Generators -&gt; PDA(push down automata)</li></ul><ul id="edf9303c-a7dd-4e8d-8a3b-1d947b3dd4fb" class="bulleted-list"><li style="list-style-type:disc">You cannot use symbols like 4 and 5 in regex but only *</li></ul><h2 id="f50cd8b7-645d-43b7-b869-39dc2d5c0d91" class="">Language Generators - Regex</h2><ul id="37f75d3a-9ce1-4387-bdf6-82d115226ef7" class="bulleted-list"><li style="list-style-type:disc">Device that can be used to generate a sentence of a language</li></ul><ul id="77caf882-58dd-4dfe-9a97-1793dde166d4" class="bulleted-list"><li style="list-style-type:disc">We use language generator mechanism called grammar</li></ul><ul id="7dbfe382-5500-4701-9c02-bc1d9622b32e" class="bulleted-list"><li style="list-style-type:disc">Regular Expression → regex is called as language generators</li></ul><ul id="3c1928be-7e85-4114-9f32-313a1bf4d633" class="bulleted-list"><li style="list-style-type:disc">Limitation of finite automata</li></ul><ul id="546fcd47-95a9-4fa7-959e-33a1d52d1929" class="bulleted-list"><li style="list-style-type:disc">Every time we use the regex, we can generate a string</li></ul><h1 id="50846b4b-bed8-4678-9a34-5f8264c9930f" class="">Backus Naur Form</h1><ul id="252619dc-12cd-43ff-9689-6ed29c2eedfb" class="bulleted-list"><li style="list-style-type:disc">Regular Grammars → <span style="border-bottom:0.05em solid">Every Regular language is a subset of Context Free Grammars</span></li></ul><ul id="2fdf5b28-8a9f-4f18-a66c-46be9c15e438" class="bulleted-list"><li style="list-style-type:disc">Context Free Grammars</li></ul><ul id="0f4ebb58-44f9-4d1f-b8f9-81f33ccf11a1" class="bulleted-list"><li style="list-style-type:disc">Context Sensitive Grammars</li></ul><ul id="0032a993-f180-41a0-bcb3-fc95d90b6f23" class="bulleted-list"><li style="list-style-type:disc">Recursively Enumerable Grammars</li></ul><ul id="8c530d9c-9829-4209-9a40-7a402f26e456" class="bulleted-list"><li style="list-style-type:disc">For example, a*b → Context Free Grammar would be<ul id="5a53e794-8e06-4d32-aa31-4c148dff4e30" class="bulleted-list"><li style="list-style-type:circle">S = M b</li></ul><ul id="e2071438-4b1a-4008-840f-d6579a035395" class="bulleted-list"><li style="list-style-type:circle">M = a M</li></ul><ul id="a79034fe-4594-4345-ad35-489f639e924e" class="bulleted-list"><li style="list-style-type:circle">M = e</li></ul></li></ul><ul id="4f6a0ce7-e23c-4c92-be8c-ab8a43c758d3" class="bulleted-list"><li style="list-style-type:disc">For some CFGs, you cannot draw regular grammars</li></ul><ul id="2739fefd-c5db-4141-826e-8d632d88d2a8" class="bulleted-list"><li style="list-style-type:disc">CFG is language generator for CFL</li></ul><h2 id="08c13db3-03a5-4c59-bdb3-698ed8619a20" class="">BNF</h2><ul id="f7f97f37-034f-4796-9fac-9797d307045c" class="bulleted-list"><li style="list-style-type:disc">Used first for describing ALGOL</li></ul><ul id="6cf77e97-a637-4180-984a-061d66eed361" class="bulleted-list"><li style="list-style-type:disc">Meta language</li></ul><ul id="869ab465-0fbf-4921-afe6-a33cedbc6502" class="bulleted-list"><li style="list-style-type:disc">uses abstract syntax structures</li></ul><ul id="1d3e7e75-8ce9-4d8a-942c-b6124b4bf6d8" class="bulleted-list"><li style="list-style-type:disc">Uses rules or productions → <code>&lt;assign&gt; → &lt;var&gt; = &lt;expr&gt;</code></li></ul><ul id="d4c2c782-5933-4427-8cbb-71eea1bb3d2a" class="bulleted-list"><li style="list-style-type:disc">NOTE: Abstractions are called non terminal </li></ul><ul id="b785d0a3-206e-4cc9-9ced-7c88c2ae0885" class="bulleted-list"><li style="list-style-type:disc">Lexemes, and tokens are called as terminals</li></ul><ul id="ef24c031-abfa-449e-b7a0-2cbc748d7f71" class="bulleted-list"><li style="list-style-type:disc">Grammar is collection of rules</li></ul><h1 id="8dd6c348-000c-47d3-8fc6-60f99ef8507f" class="">Grammar and Grammar Derivations</h1><ul id="67d3c999-5936-4481-a948-517c816a8645" class="bulleted-list"><li style="list-style-type:disc">Grammar is a generative device for defining languages</li></ul><ul id="bda8fc2f-e2a3-438a-b6ea-21d87bec9b47" class="bulleted-list"><li style="list-style-type:disc">For a normal grammar <code>M = (K, Sigma, S, delta, F)</code></li></ul><ul id="c540733e-adb7-4605-8553-f7d908a2ae1d" class="bulleted-list"><li style="list-style-type:disc">To describe a context free grammar → <code>G = (V(Set of all states), Sigma(Alphabet - Set of terminals), R(Production Rules), S(Starting non terminal))</code><ul id="6db96222-0ac2-4c25-95ff-8e8f1ed8d707" class="bulleted-list"><li style="list-style-type:circle">We need starting non terminal cause the question itself can have more than one non terminal</li></ul></li></ul><ul id="35c70610-1241-4e32-b377-0c8985b2aeca" class="bulleted-list"><li style="list-style-type:disc">Sentences of a language are generated through a sequence of applications of a set of rules starting with a non terminal</li></ul><figure id="c0fe6e38-2ddb-4649-b5bf-a7f569e348be" class="image"><a href="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled.png"><img style="width:1382px" src="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled.png"/></a></figure><ul id="246d433a-3934-4339-80fb-9f01d8f40ad9" class="bulleted-list"><li style="list-style-type:disc">Every terminal is involved in the sigma (alphabet)</li></ul><ul id="a5e9249c-af53-47f4-9454-819367cacb81" class="bulleted-list"><li style="list-style-type:disc">Here begin and end are also part of sigma</li></ul><ul id="ea1f0ae4-1fc2-4093-a6c0-811b08aa8174" class="bulleted-list"><li style="list-style-type:disc">Every sentence is a<span style="border-bottom:0.05em solid"> sentential form</span> including the last one but last one is also called <span style="border-bottom:0.05em solid">sentence</span></li></ul><figure id="d289c964-7b26-4267-b48e-9ef6fca128ca" class="image"><a href="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled%201.png"><img style="width:1497px" src="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled%201.png"/></a></figure><h2 id="874cfbb8-68ee-4ccd-946f-2a0bee1664e5" class="">Context Free Language/Grammar</h2><ul id="a311c92b-ff90-4c16-ad8b-cdaf585c10f0" class="bulleted-list"><li style="list-style-type:disc">S → a S b</li></ul><ul id="a45f0e50-766d-4e1b-bb50-96f79c06d73b" class="bulleted-list"><li style="list-style-type:disc">S → e (null)</li></ul><ul id="60b04d13-94d9-4bca-b002-0c06af910151" class="bulleted-list"><li style="list-style-type:disc">Grammar rules have LHS and RHS</li></ul><ul id="2a761e53-9cd0-41d0-8f01-606d824261eb" class="bulleted-list"><li style="list-style-type:disc">S is called the starting non terminal</li></ul><ul id="805ca134-06f4-45e1-9384-557b5af88a0c" class="bulleted-list"><li style="list-style-type:disc">If we try to construct <code>a^n b^n</code>, we cannot do using finite automata because we can’t assume n to be a fixed</li></ul><ul id="49a66e61-acd4-4b90-b232-708d12b29010" class="bulleted-list"><li style="list-style-type:disc">Recursively we can use the above statements to generate <code>a^n b^n</code> </li></ul><ul id="bd576269-185e-491a-9e9b-4874a63dabd8" class="bulleted-list"><li style="list-style-type:disc">Terminals are those which cannot be changed</li></ul><ul id="d59d5eb3-9b9f-4e67-8f0c-38046c98a0b0" class="bulleted-list"><li style="list-style-type:disc">We should not end up with a string that has non terminals</li></ul><ul id="50cfdeea-5626-4b82-94b2-da3d98074e18" class="bulleted-list"><li style="list-style-type:disc">Getting the final form is called DERIVATION</li></ul><ul id="53406f21-bf1e-46dd-8687-83f6be3eae0c" class="bulleted-list"><li style="list-style-type:disc">You can also represent this using the derivation tree → basically recursion tree</li></ul><ul id="5f7eccbf-3807-4679-abf4-7794025532e5" class="bulleted-list"><li style="list-style-type:disc">If we want it to be n≥1<ul id="61a8757d-9689-4948-b073-4b2ebe278937" class="bulleted-list"><li style="list-style-type:circle">S = a M b</li></ul><ul id="54b95bdc-dac1-4a36-bdb1-fcac6a286bf4" class="bulleted-list"><li style="list-style-type:circle">M = a M b</li></ul><ul id="4555fbde-f026-4a06-b705-e18792d3d3c7" class="bulleted-list"><li style="list-style-type:circle">M = e</li></ul></li></ul><h2 id="9850e347-1628-40a7-bcef-d99f22857f85" class="">LMD and RMD </h2><ul id="2eb6fcbb-e368-4e0e-8e8c-eb5f50edfaa1" class="bulleted-list"><li style="list-style-type:disc">Left most derivation and right most derivation</li></ul><figure id="341662ce-8775-45e5-9223-c8d40ee81de0" class="image"><a href="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled%202.png"><img style="width:1668px" src="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled%202.png"/></a></figure><h2 id="98ba6c08-3869-42d8-acac-c3c39d1de4aa" class="">Parse Tree</h2><ul id="9cf12b0a-ae13-4c08-98ef-56037a6097b9" class="bulleted-list"><li style="list-style-type:disc">Hierarchical structure of the sentences described by the grammars is known as parse tree</li></ul><figure id="3a4a5697-a5d5-4363-a3b9-35fba6677186" class="image"><a href="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled%203.png"><img style="width:1737px" src="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled%203.png"/></a></figure><h2 id="92da2915-b165-4e93-8010-a993843f1cc0" class="">Ambiguity</h2><ul id="6910dea9-f48e-4a9c-9c51-47d3bd613e69" class="bulleted-list"><li style="list-style-type:disc">Grammar that generates a sentential form for which there exist two or more distinct parse trees is known as ambiguous grammar</li></ul><ul id="587cc1f9-b200-4650-a91c-0323cbc28126" class="bulleted-list"><li style="list-style-type:disc">Ambiguous if there are two distinct LMDs or two distinct RMDs </li></ul><ul id="9016464e-5dac-4165-99d6-0f76a04b6a83" class="bulleted-list"><li style="list-style-type:disc">If there exists a LMD, there always exists a RMD</li></ul><ul id="1029f6ff-47fd-484f-b592-10adcb53739b" class="bulleted-list"><li style="list-style-type:disc">One LMD and RMD might not always imply that they are ambiguous</li></ul><ul id="e6e23d37-03ed-4d64-bad2-edcdfea1626c" class="bulleted-list"><li style="list-style-type:disc">Example<ul id="57eab3c6-06df-4114-9dfb-473db31c94b2" class="bulleted-list"><li style="list-style-type:circle">E → E + E (Starting)</li></ul><ul id="51693988-9271-4599-9e72-6e402dae95f6" class="bulleted-list"><li style="list-style-type:circle">E → E - E</li></ul><ul id="4ef9c880-b938-4b3b-bc48-554a5ab3f347" class="bulleted-list"><li style="list-style-type:circle">E → id</li></ul><ul id="0a6ecb0c-0d74-48f9-b233-86dd44b53f99" class="bulleted-list"><li style="list-style-type:circle">Give LMD for id - id + id</li></ul></li></ul><ul id="383e9809-15b6-45e9-afb9-57214640d893" class="bulleted-list"><li style="list-style-type:disc">LMD Answer<ul id="4f3eada9-1350-4936-9ed9-99892b4ae481" class="bulleted-list"><li style="list-style-type:circle">E → E + E</li></ul><ul id="716ea293-a9ec-412f-ae0d-4cfef5745618" class="bulleted-list"><li style="list-style-type:circle">E - E + E</li></ul><ul id="89d2beb9-d35a-4da6-974a-9e13b6ba640c" class="bulleted-list"><li style="list-style-type:circle">id - E + E</li></ul><ul id="38ad96d5-4550-4146-b8b7-aad7a162f088" class="bulleted-list"><li style="list-style-type:circle">id - id + E</li></ul><ul id="81a5901c-d952-4664-9d43-e9060c266e7b" class="bulleted-list"><li style="list-style-type:circle">id - id + id</li></ul></li></ul><ul id="b7b47f77-6942-447c-9a1d-280c73116317" class="bulleted-list"><li style="list-style-type:disc">RMD Answer<ul id="48cfcb34-7e13-4d15-b887-ebeaf14a91b5" class="bulleted-list"><li style="list-style-type:circle">E → E + E</li></ul><ul id="fe6903ee-ffcc-4a44-90eb-5770e00eba52" class="bulleted-list"><li style="list-style-type:circle">E + id</li></ul><ul id="e969fbab-a702-44d7-a8df-29e143632b85" class="bulleted-list"><li style="list-style-type:circle">E - E + id</li></ul><ul id="9769f5ee-0b5a-40e1-81f2-d1cdc7b052d1" class="bulleted-list"><li style="list-style-type:circle">E - id + id</li></ul><ul id="fbe46acd-364b-4cb1-810f-20ddddd0ae52" class="bulleted-list"><li style="list-style-type:circle">id - id + id</li></ul></li></ul><ul id="4dc1d309-aa31-4f37-a018-a99181ce459f" class="bulleted-list"><li style="list-style-type:disc">We get same tree regardless in this case if we draw the trees</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="19bb5832-de81-4a8b-ab77-6f035417e7ff"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Ambiguous grammar to Unambiguous grammar by adding a non terminal
Correct the order of precedence by pushing the multiplication operation down the tree by introducing a new non terminal</div></figure><h2 id="ed4c9a8d-741d-4104-8d6c-01b382451cb7" class="">Recursive Grammar</h2><ul id="d3046562-2c76-4a30-a06a-0e3e68fcd85f" class="bulleted-list"><li style="list-style-type:disc">Left Recursive Grammar: E → E + T</li></ul><ul id="9a231507-8c78-46f0-9571-f9503ba24443" class="bulleted-list"><li style="list-style-type:disc">Right Recursive Grammar: E → T + E</li></ul><h2 id="d198fef8-5bbe-4463-904e-9f5d032bdafe" class="">Extended BNF </h2><ul id="16f933d7-fb40-4c19-b63e-53e05171a651" class="bulleted-list"><li style="list-style-type:disc">Optional part of RHS<ul id="3f2b125c-cc4c-4e71-ba1b-ef73fe99f80e" class="bulleted-list"><li style="list-style-type:circle"><code>&lt;if_stmt&gt; -&gt; if (&lt;expression&gt;) &lt;statement&gt; [else &lt;statement&gt;]</code></li></ul><ul id="25706636-8a69-4cfa-87b8-195ab6a61db4" class="bulleted-list"><li style="list-style-type:circle">Whatever comes in square brackets is optional</li></ul></li></ul><ul id="84f15c8c-6878-4c8b-9339-a160655d0aa5" class="bulleted-list"><li style="list-style-type:disc">Repetitions<ul id="48115d1e-8354-45f2-af39-2874e7b68917" class="bulleted-list"><li style="list-style-type:circle"><code>&lt;ident_list&gt; -&gt; &lt;identifier&gt; {, &lt;identifier&gt;}</code> Zero or more</li></ul><ul id="0a11d1f4-e15f-4889-9edd-8c8cbbe046af" class="bulleted-list"><li style="list-style-type:circle"><code>&lt;ident_list&gt; -&gt; &lt;identifier&gt; {, &lt;identifier&gt;}+</code> One or more</li></ul><ul id="6bf1df35-e458-42e9-b43c-2572d9a2cf3e" class="bulleted-list"><li style="list-style-type:circle">Content of curly braces repeating more than once</li></ul></li></ul><ul id="5e89dc34-a5b7-414a-804f-3c91ce9cddfb" class="bulleted-list"><li style="list-style-type:disc">Alternation<ul id="d4deb298-ff8f-4352-9ea4-b20749e8f38f" class="bulleted-list"><li style="list-style-type:circle"><code>&lt;term&gt; -&gt; &lt;term&gt; (* | / | %) &lt;factor&gt;</code></li></ul><ul id="0a78a234-a2fd-4ca3-81ce-0fb6d3d5e4ba" class="bulleted-list"><li style="list-style-type:circle">In BNF, a description of this &lt;term&gt; would require 3 rules</li></ul><ul id="8acbe465-6a8b-4841-92ec-098100409e35" class="bulleted-list"><li style="list-style-type:circle"><code>&lt;term&gt; → &lt;term * &lt;factor&gt; | &lt;term&gt; / &lt;factor&gt; | &lt;term&gt; % &lt;factor&gt;</code></li></ul></li></ul><figure id="d90e14d6-b79f-4af3-a728-4baf1053e0ab" class="image"><a href="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled%204.png"><img style="width:1210px" src="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled%204.png"/></a></figure><h2 id="edf7644b-7ff5-4460-8657-50cd2fd4b144" class="">Grammar and Recognizers</h2><ul id="d4a6715f-6a21-4a67-bf9b-0ddbef3d7b95" class="bulleted-list"><li style="list-style-type:disc">We use tools like Lex(Lexical Analyzer Generator) and Yacc(Syntax Analyzer Generator)</li></ul><ul id="db8ef68a-a349-48e0-a761-42c3d00c7718" class="bulleted-list"><li style="list-style-type:disc">Flex and Bison are modern replacements for the classic lex and yacc tools</li></ul><h2 id="0834ef55-14a1-4d78-95b6-718a5e21c42a" class="">Example 1</h2><ul id="acb7bf89-6978-480a-80d4-608c1befa0ae" class="bulleted-list"><li style="list-style-type:disc">E → E + E</li></ul><ul id="d05536e8-056c-4788-aa57-1fc48d8cb5b7" class="bulleted-list"><li style="list-style-type:disc">E → E * E</li></ul><ul id="bd38713d-69be-4f89-9dab-0b8c62c6745a" class="bulleted-list"><li style="list-style-type:disc">E → (E)</li></ul><ul id="b871e809-8125-4e0c-9129-a1e18fe5d497" class="bulleted-list"><li style="list-style-type:disc">E → id</li></ul><ul id="cd330f84-c9a9-46c2-a537-3f96b2c2778c" class="bulleted-list"><li style="list-style-type:disc">Prove that the given language is ambiguous </li></ul><ul id="bb046e7d-af31-4557-83ed-a3e3b9db0239" class="bulleted-list"><li style="list-style-type:disc">We say need to get id + id * id</li></ul><ul id="298e8024-eabb-44a4-bccf-df989613959c" class="bulleted-list"><li style="list-style-type:disc">If we start with E<ul id="df1da3da-772e-43a9-a0de-c2942753ffd9" class="bulleted-list"><li style="list-style-type:circle">E → E + E</li></ul><ul id="a8ee0601-2b2d-4082-99a8-eba062830857" class="bulleted-list"><li style="list-style-type:circle">E + E * E</li></ul><ul id="3b817518-d2a0-4d3c-9761-1e71137f5a69" class="bulleted-list"><li style="list-style-type:circle">id + E * E</li></ul><ul id="d69477c8-0fc8-4140-8855-3d14c214c89b" class="bulleted-list"><li style="list-style-type:circle">id + id * E</li></ul><ul id="2ab56d20-ffee-43ff-8f84-cb9e1c8a3067" class="bulleted-list"><li style="list-style-type:circle">id + id * id</li></ul></li></ul><ul id="d6686f2c-157b-40a4-82e7-0ca2ffa019cf" class="bulleted-list"><li style="list-style-type:disc">Otherwise<ul id="fa2ef584-fe7c-44a0-aab0-3795a24daa18" class="bulleted-list"><li style="list-style-type:circle">E → E * E</li></ul><ul id="84346760-6788-43ba-a4e6-a1d3a0fda474" class="bulleted-list"><li style="list-style-type:circle">E + E * E</li></ul><ul id="bfe7deb4-d7b1-42b4-acc9-e266ee6aeefd" class="bulleted-list"><li style="list-style-type:circle">id + E * E</li></ul><ul id="f13b7fd4-a424-4e64-bb09-1884c4550aa2" class="bulleted-list"><li style="list-style-type:circle">id + id * E</li></ul><ul id="88195c28-046d-4d2d-8792-e9bb4d82e898" class="bulleted-list"><li style="list-style-type:circle">id + id * id</li></ul></li></ul><ul id="091239f3-5295-4b40-9f6e-94ffb54e91d8" class="bulleted-list"><li style="list-style-type:disc">Both are LMDs, so these are ambiguous. In exam we don’t have to draw parse tree specifically</li></ul><h2 id="97928785-d92c-4844-bc26-0f2fbd59ccab" class="">Example 2</h2><ul id="15f32b59-68f2-4c33-a23e-0ec83996e0fa" class="bulleted-list"><li style="list-style-type:disc">Language a(a* + b*)b</li></ul><ul id="4d174487-c4be-4f3b-bd66-c8d66614e597" class="bulleted-list"><li style="list-style-type:disc">S → a M b</li></ul><ul id="69cfe620-6d8f-4929-9b0d-efe7f847e075" class="bulleted-list"><li style="list-style-type:disc">M → a A</li></ul><ul id="4624fc5a-2001-4b7f-aad7-d4c11bc91def" class="bulleted-list"><li style="list-style-type:disc">A → a A</li></ul><ul id="4b4fa496-7eb3-4768-a13f-f7a37f052c72" class="bulleted-list"><li style="list-style-type:disc">A → e</li></ul><ul id="c1f30375-2005-4b89-af91-643c44ae6410" class="bulleted-list"><li style="list-style-type:disc">M → b B</li></ul><ul id="940c3bf0-c49a-41d2-baf0-32350d597ae7" class="bulleted-list"><li style="list-style-type:disc">B → b B</li></ul><ul id="56024dee-0e05-4a04-b7f3-987361ba8e04" class="bulleted-list"><li style="list-style-type:disc">B → e</li></ul><h1 id="f7055e27-6e82-4a81-82f4-3e0500b5d401" class="">Attribute Grammars</h1><ul id="c6b3ce4b-a0d2-4f28-98e4-de7bacdb51d7" class="bulleted-list"><li style="list-style-type:disc">Extension of CFG and is a device used to describe more of the structure of a language than can be described by simple CFG</li></ul><ul id="42c675f5-af10-428e-900d-1e8fa779f543" class="bulleted-list"><li style="list-style-type:disc">These extensions allow certain rules to be conveniently described such as type compatibility</li></ul><ul id="dd6d88aa-2a49-41ff-bd91-8c960383c7f0" class="bulleted-list"><li style="list-style-type:disc">Synthesized attributes are used to pass <span style="border-bottom:0.05em solid">semantic information up a parse tree</span>, while inherited attributes pass semantic information<span style="border-bottom:0.05em solid"> down and across a tree</span></li></ul><h1 id="b1e265d6-ce3f-4519-8422-140e3fba069d" class="">Static Semantics</h1><ul id="4c595a3e-e161-427c-ba01-d5d8777f32e0" class="bulleted-list"><li style="list-style-type:disc">Some characteristics are difficult to describe by BNF and some are impossible</li></ul><ul id="fc75b587-924d-44b5-9ceb-8957957fb47b" class="bulleted-list"><li style="list-style-type:disc">Example: Type compatibility or Declaration of variable before it is referenced</li></ul><ul id="ec2c5be6-f65c-4499-b3c6-16cb2b2d85fb" class="bulleted-list"><li style="list-style-type:disc">The static semantics of a language is only indirectly related to the meaning of programs during the execution, rather it has to do with the legal format of the program → syntax rather than semantics</li></ul><ul id="ddb56583-cd63-4fe3-b93a-142af45773d1" class="bulleted-list"><li style="list-style-type:disc">Static → checks performed at compile time</li></ul><ul id="7e4d094a-e118-4783-afbf-b5d30dd5d962" class="bulleted-list"><li style="list-style-type:disc">Attribute grammar is a mechanism devised to describe and check the correctness of static semantic rules of a program</li></ul><ul id="60241353-f5bb-46e1-8209-a672db9a4873" class="bulleted-list"><li style="list-style-type:disc">Attribute grammars are CFGs, which have been added with<ul id="7af29ab5-93cc-4d2d-b58d-17a7ef245b77" class="bulleted-list"><li style="list-style-type:circle">Attributes <ul id="d378058a-b00e-4cf1-a011-9a5b2c28854b" class="bulleted-list"><li style="list-style-type:square">Any number of attributes and are associated with the grammar symbols (both terminals and non terminals) and are similar to variables with assigned values</li></ul></li></ul><ul id="3988cea4-5b77-4fa8-a850-5ec6ff3739de" class="bulleted-list"><li style="list-style-type:circle">Attribute computation functions<ul id="9733234c-2ecb-4b5a-8e32-f8fb6f2059e6" class="bulleted-list"><li style="list-style-type:square">Semantic functions: are associated with grammar rules and are used to specify how the attribute values are computed</li></ul></li></ul><ul id="a09d6048-c026-45b2-91f1-c9c0a441edd2" class="bulleted-list"><li style="list-style-type:circle">Predicate functions<ul id="41991472-b7fa-448c-a62a-5056f016991d" class="bulleted-list"><li style="list-style-type:square">State the semantic rules associated with the grammar rules</li></ul></li></ul></li></ul><ul id="d186084c-5746-4165-b0a2-eca526359b1f" class="bulleted-list"><li style="list-style-type:disc">We have two types of attributes A(X) = S(X) U I(X)<ul id="ca3e05b2-9d5c-4f0d-85dc-2fe658c88d5f" class="bulleted-list"><li style="list-style-type:circle">Synthesized attributes: computed based values of children</li></ul><ul id="1567538d-fd4f-4244-a748-21cd05afc6e7" class="bulleted-list"><li style="list-style-type:circle">Inherited attributes: computed based on parents and siblings→ used to send semantic details across the parse tree</li></ul></li></ul><ul id="d3055f4e-3078-48eb-8a45-64a63ff2f285" class="bulleted-list"><li style="list-style-type:disc">Semantic functions and Predicate functions</li></ul><ul id="acca5313-1f5f-4e31-a5b2-0676321de5c2" class="bulleted-list"><li style="list-style-type:disc">Intrinsic attributes: are synthesized attributes of leaf nodes whose values are determined outside the parse tree → stored in symbol table</li></ul><h3 id="2b92c224-120d-4280-a9c6-ea4b9e0fafbb" class="">Example for describing a rule</h3><ul id="9898ff87-bbd7-4a2f-b3ab-77ee46a2ca3b" class="bulleted-list"><li style="list-style-type:disc">If same nonterminal occurs multiple times, we give numbers to them</li></ul><ul id="1978d890-6b9d-4a42-aa77-9ce9db95ba0e" class="bulleted-list"><li style="list-style-type:disc">Then we also use attributes to compare to symbols</li></ul><pre id="35164176-fd22-45af-94fa-2c17e1541c07" class="code code-wrap"><code>&lt;assign&gt; -&gt; &lt;var&gt; = &lt;expr&gt;
&lt;expr&gt; -&gt; &lt;var&gt; + &lt;var&gt; | &lt;var&gt;
&lt;var&gt; -&gt; A | B | C</code></pre><ul id="9cde3ebb-46b0-4349-882b-0c7d941c9a4d" class="bulleted-list"><li style="list-style-type:disc">You can attach any number of attributes to a node</li></ul><ul id="5f918d43-5088-4320-be8e-71d07d50008b" class="bulleted-list"><li style="list-style-type:disc">We have actual type, expected type for each token in this case and this is for every node regardless of if it’s a sign or a non terminal</li></ul><ul id="39fc565f-0a27-45ea-af15-a5e633ab8c4e" class="bulleted-list"><li style="list-style-type:disc">Actual type → synthesized</li></ul><ul id="3f6022c5-aae9-4403-bdcf-1acdcbea5c07" class="bulleted-list"><li style="list-style-type:disc">Expected rule → inherited</li></ul><figure id="beaa34aa-6d1c-4d29-bc26-62c87f2d0862" class="image"><a href="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled%205.png"><img style="width:907px" src="Syntax%20and%20Semantics%209983f4edf2154695bd10d423acceaa37/Untitled%205.png"/></a></figure><h2 id="b8277fe6-b611-47f3-9e7e-f272a69b650c" class="">Attribute Grammar for Simple Assignment Statements</h2><ol type="1" id="256361af-a814-48cd-85b7-ae555fb6ad0a" class="numbered-list" start="1"><li>Syntax Rule: <code>&lt;assign&gt; → &lt;var&gt; = &lt;expr&gt;</code><p id="7aae0145-c823-4308-a8d7-70ac2624369b" class="">Semantic Rule: <code>&lt;expr&gt;.expected_type ← &lt;var&gt;.actual_type</code></p></li></ol><ol type="1" id="9fe9f5ee-68e6-4669-a1ed-1cff1bae6076" class="numbered-list" start="2"><li>Syntax Rule: <code>&lt;expr&gt; → &lt;var&gt;[2] + &lt;var&gt;[3]</code><p id="55d907a9-5a09-4221-ac9a-c329f9d8b52e" class="">Semantic Rule: <code>&lt;expr&gt;.actual_type ← if (&lt;var&gt;[2].actual_type = int) and (&lt;var&gt;[3].actual_type = int) then int else real end if</code></p><p id="f07dfa65-1841-422d-9c6b-8b6e0a6e32cf" class="">Predicate: <code>&lt;expr&gt;.actual_type == &lt;expr&gt;.expected_type</code></p></li></ol><ol type="1" id="d937a28a-1b25-4f55-a2af-2f290c431eb1" class="numbered-list" start="3"><li>Syntax Rule: <code>&lt;expr&gt; -&gt; &lt;var&gt;</code><p id="33b269b1-489a-4b32-9bd2-0a85ca556d23" class="">Semantic Rule: <code>&lt;expr&gt;.actual_type &lt;- &lt;var&gt;.actual_type</code></p><p id="e193f179-dbdc-4e66-a48d-7a35a59b2290" class="">Predicate: <code>&lt;expr&gt;.actual_type &lt;- &lt;var&gt;.actual_type&gt;</code></p></li></ol><ol type="1" id="68020517-6894-41d8-be1d-ef90a8b583d1" class="numbered-list" start="4"><li>Syntax Rule: &lt;var&gt; → A | B | C<p id="fa0da43f-1ba2-4aa6-9d9d-1882dec2a45e" class="">Semantic Rule: <code>&lt;var&gt;.actual_type ← look-up(&lt;var&gt;.string)</code></p></li></ol><p id="3bd4587c-64a5-4236-92e4-aae6624829ac" class="">The look up function looks up the variable name in the symbol table and returns the variable’s type</p><p id="7f81c374-f1fc-488d-bfda-e6fd2a5b849b" class="">Here variable type is intrinsic. </p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="bee25aff-a849-49a6-a230-6fb229abdf99"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Bottom to top → we use actual type
Top to bottom → we use expected type</div></figure><h2 id="14653357-982e-491a-90bd-1fb635dc98ae" class="">Computing the Attribute values</h2><ul id="0056dd0e-b347-47e4-8fc1-75dc84e6aad8" class="bulleted-list"><li style="list-style-type:disc">Computing the attribute values of parse tree: which is sometimes known as decorating the parse tree<ul id="bf2fb436-5932-4bfe-8142-3248ae84c5a8" class="bulleted-list"><li style="list-style-type:circle">Top Down Approach: if all attributes are inherited</li></ul><ul id="76ca11de-87f1-42d9-abcb-5fc441d0e0fc" class="bulleted-list"><li style="list-style-type:circle">Bottom Up Approach: if all attributes are synthesized</li></ul><ul id="bc48e74f-46bc-4fd3-843d-7bc80302a5a7" class="bulleted-list"><li style="list-style-type:circle">Mixed Approach: if attributes are of both types</li></ul></li></ul><ul id="f0065e42-d58a-4456-8346-69586a547758" class="bulleted-list"><li style="list-style-type:disc">If all attributes have been computed, the tree is called fully attributed tree</li></ul><ul id="be810a41-ca7a-40cd-a062-fced2b400853" class="bulleted-list"><li style="list-style-type:disc">Compute left to right to avoid cyclic dependency for inherited attributes</li></ul><ul id="d2e18b6e-631b-4956-9ec5-8f7297f32244" class="bulleted-list"><li style="list-style-type:disc">When a predicate fails, don’t go up, there is no point</li></ul><h1 id="b9930dae-1796-4a82-b332-291b376bb56a" class="">Describing the meaning of Programs (Dynamic Semantics)</h1><ul id="bafc9eb7-3f7d-4360-83bc-2529a06a3e7f" class="bulleted-list"><li style="list-style-type:disc">Now we take up the task of describing the dynamic semantics of a constructs of a programming language</li></ul><ul id="6f359f6b-acfe-405a-8915-3af67de65069" class="bulleted-list"><li style="list-style-type:disc">It is easy to describe syntax than semantics. It is because of the power and naturalness of the available notations to describe these</li></ul><ul id="87a5ee10-c3f6-4512-829d-c17be2931f6e" class="bulleted-list"><li style="list-style-type:disc">Compiler designers must know exactly what language constructs mean to implement them correctly</li></ul><ul id="2069d087-74c7-47b5-a3ac-475d7a11b02f" class="bulleted-list"><li style="list-style-type:disc">SW developers must know precisely what they statement of a language does before they can be used effectively</li></ul><ul id="4c7e51df-9d42-43bd-8c6b-2a716cf749c8" class="bulleted-list"><li style="list-style-type:disc">Both typically determine the semantics by reading English explanations in language manuals</li></ul><h2 id="1f4e4836-a8d5-48d2-8a13-4334c0635414" class="">Operational Semantics (States)</h2><ul id="50fcf280-6c8d-4cbe-951f-b05a4475e0a2" class="bulleted-list"><li style="list-style-type:disc">The idea behind OS is to describe the meaning of statements or program by specifying the effects of running it on the machine</li></ul><ul id="75c207c7-f820-40f0-a390-6593e7ef0285" class="bulleted-list"><li style="list-style-type:disc">The effects on the machine are viewed as the sequence of changes in it’s state</li></ul><ul id="4d4d86b1-e662-46d2-a38c-ffb8d9116a6b" class="bulleted-list"><li style="list-style-type:disc">The machine’s state is the collection of the values in its storage</li></ul><ul id="8a1278de-ae92-4561-a077-9e3b4d8058c1" class="bulleted-list"><li style="list-style-type:disc">Programmers write test programs</li></ul><ul id="03533aff-46d5-43f8-8dc5-80459d90b055" class="bulleted-list"><li style="list-style-type:disc">Using machine language for OS is difficult due to complexity and large number of instructions</li></ul><ul id="0fe8c502-660c-49c8-91c8-1421db35740b" class="bulleted-list"><li style="list-style-type:disc">Natural Operational Semantics → only the final result</li></ul><ul id="08c671f4-738a-4ac4-aae3-c418f8b8e443" class="bulleted-list"><li style="list-style-type:disc">Structural Operational Semantics → complex sequence of state changes</li></ul><ul id="07181a12-fe8f-4b7a-bed8-f032b713cc8b" class="bulleted-list"><li style="list-style-type:disc">Usually intermediate languages are used to describing the operational semantics</li></ul><ul id="0a5eeb01-6eb3-40cc-b68a-018626e04faa" class="bulleted-list"><li style="list-style-type:disc">Causes problems if there are a lot of instructions </li></ul><h2 id="b98efc73-1546-40dd-b956-9818c4facc13" class="">Denotational Semantics (Math)</h2><ul id="cc267e76-e492-4508-ae4c-1c2ad1404814" class="bulleted-list"><li style="list-style-type:disc">Is the most rigorous and most widely known formal method for describing the dynamic semantics of the program</li></ul><ul id="9b0a01f3-0d66-42cf-8c31-4d195ec4ff41" class="bulleted-list"><li style="list-style-type:disc">It is solidly based on <span style="border-bottom:0.05em solid">recursive function theory</span></li></ul><ul id="e697d592-1a4c-4ac6-99f3-2fe9a5e83be2" class="bulleted-list"><li style="list-style-type:disc">In OS → Programming constructs → simpler PL constructs</li></ul><ul id="a45b9563-6c09-4d60-bd7e-a1432f250191" class="bulleted-list"><li style="list-style-type:disc">In DS → Language constructs → mathematical objects</li></ul><ul id="8f171c11-0e96-41b7-b812-a01621bd5d4b" class="bulleted-list"><li style="list-style-type:disc">But it <span style="border-bottom:0.05em solid">does not model step by step computational processing</span> of programs</li></ul><ul id="270fb8f3-fa66-4a9d-b944-1e10f67302ce" class="bulleted-list"><li style="list-style-type:disc">Syntactic objects are <span style="border-bottom:0.05em solid">mapped by semantic functions to mathematical objects</span></li></ul><ul id="6b301626-50d5-4ed6-9018-d0de1c71deff" class="bulleted-list"><li style="list-style-type:disc">This method is denotational because the math objects denote the meaning of syntactic entities</li></ul><ul id="787653a1-6521-4efd-a79a-1d7639a6d40b" class="bulleted-list"><li style="list-style-type:disc">A mapping function has <span style="border-bottom:0.05em solid">syntactic domain and semantic domain</span>(range)</li></ul><pre id="cf867537-1aeb-4848-a533-20c4443d963e" class="code code-wrap"><code>&lt;bin_num&gt; -&gt; &#x27;0&#x27; | &#x27;1&#x27; | &lt;bin_num&gt; &#x27;0&#x27; | &lt;bin_num&gt; &#x27;1&#x27;</code></pre><pre id="acd6808d-a370-4bd2-9840-289b59d97c52" class="code code-wrap"><code>Mbin(&#x27;0&#x27;) = 0
Mbin(&#x27;1&#x27;) = 1
Mbin(&lt;bin_num&gt;&#x27;0&#x27;) = 2 * Mbin(&lt;bin_num&gt;)
Mbin(&lt;bin_num&gt;&#x27;1&#x27;) = 2 * Mbin(&lt;bin_num&gt;) + 1</code></pre><h2 id="a2a18eb7-9ab8-452c-bae3-ad8d8ae843be" class="">Axiomatic Semantics (Logical Statements or Axioms)</h2><ul id="8b22d5f3-046f-4a82-a5d9-d78dd9b392a6" class="bulleted-list"><li style="list-style-type:disc">State of program before a set of instructions or steps</li></ul><ul id="baae2ed5-6423-4268-8621-678d0f847f51" class="bulleted-list"><li style="list-style-type:disc">An axiom is a logical statement which is assumed to be true</li></ul><ul id="c2234d9b-990a-4c34-8ba5-dbaa6b139cb9" class="bulleted-list"><li style="list-style-type:disc">Axiomatic Semantics is based on mathematical logic</li></ul><ul id="06440b0c-cb76-4a76-b3f7-a3e168e205f5" class="bulleted-list"><li style="list-style-type:disc">Have two applications<ul id="6bb70fe7-49cb-4359-b928-62dac6b6098d" class="bulleted-list"><li style="list-style-type:circle">Program verification</li></ul><ul id="51b5857f-7ea8-47fd-a9df-85ef5d374160" class="bulleted-list"><li style="list-style-type:circle">Program semantic specification</li></ul></li></ul><ul id="8ccbafbf-bd73-4553-899c-5ed6e0a45153" class="bulleted-list"><li style="list-style-type:disc">We use notions:<ul id="09723df3-c930-4201-911f-b43ce5c3ac3d" class="bulleted-list"><li style="list-style-type:circle">Assertions/Predicates: Logical expressions used in axiomatic semantics</li></ul><ul id="0f77c3a3-7cfd-471c-93a3-ba4a402d8610" class="bulleted-list"><li style="list-style-type:circle">Precondition: assertion immediately before the statement that describes constraints on program variables</li></ul><ul id="ff01c154-c403-4122-b2f7-2b231b117b03" class="bulleted-list"><li style="list-style-type:circle">Weakest precondition → most restrictive</li></ul><ul id="0f18d806-bad0-453a-9c8e-8e58dae54aa7" class="bulleted-list"><li style="list-style-type:circle">Post condition: assertion immediately after the execution statement that describes constraints on program variables</li></ul></li></ul><pre id="7aa3b37f-9887-413c-89ac-e7a4f1aadc20" class="code code-wrap"><code>a = b/2 - 1 { a &lt; 10 }
--&gt; b/2 - 1 &lt; 10 --&gt; b &lt; 22 (weakest pre condition of the statement)</code></pre><pre id="1469eb6c-4615-4d70-af50-7e262ce82aaa" class="code code-wrap"><code>x = x + y - 3 { x &gt; 10 }
--&gt; x + y - 3 &gt; 10 --&gt; y &gt; 13 - x (weakest precondition of the statement)</code></pre><h3 id="db927056-f562-414d-bb4b-0966478272b2" class="">Sequences</h3><pre id="ab35d8a4-53e1-4de3-83a5-e1b6fb66496c" class="code code-wrap"><code>y = 3x + 1
x = y + 3
{x &lt; 10}</code></pre><ul id="8dd6de4e-979a-4aac-b453-4cb863e07ce2" class="bulleted-list"><li style="list-style-type:disc">We go backwards</li></ul><ul id="f3b4c089-fb5f-453c-afd9-40afc4232f24" class="bulleted-list"><li style="list-style-type:disc">We get y + 3 &lt; 10</li></ul><ul id="94783395-48a3-4903-a225-6ce50b78f2e6" class="bulleted-list"><li style="list-style-type:disc">We get y &lt; 7</li></ul><ul id="04cb3205-4297-4254-b7de-d0ace958ab02" class="bulleted-list"><li style="list-style-type:disc">then we get 3x + 1 &lt; 10</li></ul><ul id="876d8d71-a589-4249-91c5-dc64c14d12fc" class="bulleted-list"><li style="list-style-type:disc">We get 3x &lt; 9</li></ul><ul id="a6fc8ad7-9b1c-4d2b-aa39-19b4d41d0568" class="bulleted-list"><li style="list-style-type:disc">We get x &lt; 3 → precondition of both the first statement and the pair of assignment instructions</li></ul><h3 id="dc6f427b-0317-4d6d-a854-92e57119c353" class="">Selection</h3><pre id="d000862a-b5b9-4de5-887b-964393768c41" class="code code-wrap"><code>if x &gt; 0 then
	y = y - 1
else 
	y = y + 1</code></pre><ul id="74d8f866-ee1d-4085-80fc-550ffddd89fb" class="bulleted-list"><li style="list-style-type:disc">Suppose the post condition Q for then selection statement is y &gt; 0, We can use the axiom of assignment on the then clause</li></ul><ul id="395256be-86c2-4c00-bd1e-f5b0e9d910c3" class="bulleted-list"><li style="list-style-type:disc">y = y - 1 { y &gt; 0 } → y - 1 &gt; 0 → y &gt; 1</li></ul><ul id="57d8cf22-86e6-4106-8c93-39877248ee91" class="bulleted-list"><li style="list-style-type:disc">It can be used as the P part of the precondition for the then clause</li></ul><ul id="ea0112bc-051e-454a-a453-79bc8867b2b1" class="bulleted-list"><li style="list-style-type:disc">For the else clause, we get → y &gt; -1 </li></ul><ul id="39e0f2b8-753c-4798-9dbe-7b617817cac9" class="bulleted-list"><li style="list-style-type:disc">Final precondition we get y &gt; 1</li></ul><h3 id="1ad4de07-283d-4439-8a45-c521df4bf8d4" class="">Loops</h3><ul id="5b0a57b0-042b-4c6a-955f-59368267eec9" class="bulleted-list"><li style="list-style-type:disc">while y &lt;&gt; x do y = y + 1 end { y = x }</li></ul><ul id="ff9db1a0-c61f-4e12-ab8f-3372dd31c04c" class="bulleted-list"><li style="list-style-type:disc">{ y = x }</li></ul><ul id="3a2b4d89-c8c6-4899-bdd7-aa9298ecbeca" class="bulleted-list"><li style="list-style-type:disc">For one iteration, it becomes<ul id="5649fd89-761c-4a07-babc-72a08ce5cb18" class="bulleted-list"><li style="list-style-type:circle">wp(y = y + 1, {y = x}) = { y + 1 = x } → { y = x - 1 }</li></ul></li></ul><ul id="698596e6-fe39-4171-ae92-aa45aaa626b2" class="bulleted-list"><li style="list-style-type:disc">For two iterations<ul id="96d2804f-b3f0-44e1-b3f5-10f71ffdbb55" class="bulleted-list"><li style="list-style-type:circle">wp(y = y+1, {y = x - 1}) = { y + 1 = x - 1 } or { y = x - 2 }</li></ul></li></ul><ul id="47c66c25-6ff9-4450-943e-ef6810d1e7cd" class="bulleted-list"><li style="list-style-type:disc">For three iterations<ul id="67645f08-f9df-4f8a-b83b-aa1b949d7e97" class="bulleted-list"><li style="list-style-type:circle">wp(y = y + 1, { y = x - 2 }) = { y + 1 = x - 2 } or { y = x - 3 }</li></ul></li></ul><h3 id="3fdebd6c-5101-4d8e-954a-2dc19faeb9b1" class="">Program Proofs (for checking the correctness)</h3><pre id="44e8a5b1-738c-401e-83ab-2235f608988e" class="code code-wrap"><code>{x = A and y = B}
t = x;
x = y;
y = t;
{x = B AND y = A}
</code></pre><ul id="cfb2e2b7-fa2e-4d7c-a4e9-1967eaae124d" class="bulleted-list"><li style="list-style-type:disc">{x = B AND y = A} → {x = B AND t = A} → {y = B AND t = A} → {y = B AND x = A}</li></ul></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>