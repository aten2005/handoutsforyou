<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>C Programming Notes</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="93b6bc76-4c3f-4836-995d-4316f2674556" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">🗜️</span></div><h1 class="page-title">C Programming Notes</h1></header><div class="page-body"><nav id="58a57a93-4657-4f09-a783-545b0e87bc2c" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#177525e8-d545-4a94-83af-73d0e50bac91">Number System</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e1b0a006-ab86-4967-9ad7-0b1008ce560c">C Programming</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0cc8e7db-0278-400c-9289-2051aa8fd991">Basics</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#672dcd2a-a79a-4c22-9d40-f8cbd8d7e585">Rules</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2804ac8c-a9bb-4389-b1f1-a516c4a83fb9">Character Set</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b80d61bb-142d-4541-b7e6-67ab86866595">Format Specifiers</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c6bd0162-a941-4001-9f7c-f4b856c32af4">C tokens</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#767d708b-ac4e-4aa3-8370-9891a27b3210">Comma Operator</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#444d9913-f401-4bff-8f1b-a694d7f2322f">Increment and decrement Operator</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b77c942a-d93d-4509-a6d3-5a9e178c62bc">Operator Precedence:</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4dc67f44-ad0a-4aa7-aaea-b1cf0f6aa5a7">Comparing Operators</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#30e8534f-583d-4d0b-a3f0-2f999e0b0484">Conditional Operator</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ae3e7cd0-28cd-4c4c-bd30-fd424deaf3e5">Loops</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7fb15493-1606-4d74-af54-e275bead3a82">Arrays and other data structures</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6404148a-e6de-47da-8edd-2cae760669b6">Precedence of Array references</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1835b5d8-c241-4b4c-8117-12c650bcc077">User-defined functions</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bcc2a22b-adc4-4b07-bcd0-e62d82df14bc">Parameter Passing in C</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c28d6daa-4ce9-4f8a-966a-1f8bf0e1e9c3">Recursion</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d65b32ab-7223-4070-9aa5-5855f3e6ee8e">1D Arrays</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2d657011-4c94-44bb-af0a-c2fa514f5d7a">2D Arrays</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7d2ffe4e-fdef-4739-b784-681348e76d86">Character Arrays and Strings</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1818c8ce-7138-4cca-b695-cdb2d53ac7e5">fgets and gets and fputs and puts</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c23305ad-84a8-45b4-b262-c28963652c52">Arithmetic on Characters</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#1f2bd59e-b574-4b11-a41c-523e6235766b">String Manipulation Functions</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2cb06676-d602-4bf3-9d5e-44272cabd44c">Structures</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#afed2e9a-a37b-40f5-9b2a-606d60d85300">Unions</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2f2fa612-5eb1-4c02-84ab-229fe4b0db68">Pointers</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d49fe040-5758-4853-a860-d1086e619f64">2D pointer arithmetic</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ff065986-375c-4e43-aadb-4822b59bd6af">Wild Pointer</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5290a608-d21a-4391-be3e-ab24e622c349">Pointer Precedence</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2e16e8ba-10d3-453c-aa8a-7b7e4a9dc4a6">File Management</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7fd03fae-b2b0-44fd-8691-282284c5df9b">Dynamic Memory Allocation</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#215a9230-0f9b-450d-912d-565c4818c9d1">Linked Lists</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6c1719db-dbf4-4e19-9e5a-c639468f2f8c">Storage Classes</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4dc17f58-2028-4120-80ad-aa1bcc55ce6e">Important Stuff</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6f5da12a-2783-4163-8e9a-2c1786ce3d25">Exam Tips:</a></div></nav><div id="140c4f84-6f75-4c3e-a30d-eafde398e4e2" class="column-list"><div id="7439516c-3883-4cd5-aa97-643cdec2ec55" style="width:37.5%" class="column"><figure id="cda38be4-9da0-4c7c-b3e5-6282fa26724a" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image14.png"><img style="width:288px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image14.png"/></a></figure></div><div id="9ffed995-f1c2-44d9-8aaf-433e0f1b1cf8" style="width:62.5%" class="column"><figure id="6b23bc8c-e05e-4965-8492-ac5358261c37" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image10.png"><img style="width:432px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image10.png"/></a></figure></div></div><figure id="3ce3861d-e700-49fd-bce1-a87ab98282ae" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image16.png"><img style="width:432px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image16.png"/></a></figure><figure id="0af26aa5-2cb6-41af-a724-6c98c5ac581f" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image13.png"><img style="width:432px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image13.png"/></a></figure><h1 id="177525e8-d545-4a94-83af-73d0e50bac91" class="">Number System</h1><ol type="1" id="c34f1b65-e53f-4961-bdf8-65be127ddbff" class="numbered-list" start="1"><li>If base is x, it can only have digits from 0 to x-1</li></ol><ol type="1" id="b39a78f3-072b-4826-b7a0-018ff8fb9ff1" class="numbered-list" start="2"><li>(656)10 = 6*10^2 + 5*10^1 + 6*10^0</li></ol><ol type="1" id="9301a47f-31db-4bdd-b80d-f8f54e487359" class="numbered-list" start="3"><li>()x = ()10 –&gt; (545)6 = 5*6^0 + 4*6^1 + 5*6^2</li></ol><ol type="1" id="905043cb-ca15-4a3b-8bc5-2de8198422b4" class="numbered-list" start="4"><li>(565.556)10 = 5*10^2 + 6*10^1 + 5*10^0 + 5*10^-1 + 5*10^-2 + 5*10^-3</li></ol><ol type="1" id="923f933c-712b-42f4-8201-9395b54790ff" class="numbered-list" start="5"><li>Same as above if we have binary to decimal and binary has points</li></ol><ol type="1" id="8fc7f13b-d710-41eb-a6b1-df3349b05260" class="numbered-list" start="6"><li>Now, 10-A, 11-B, 12-C, 13-D…</li></ol><ol type="1" id="a602716d-4f33-4072-b43c-1f7a306de92b" class="numbered-list" start="7"><li>(1A5)16 = 5*16^0+10*16^1+1*16^2</li></ol><ol type="1" id="fc91db6e-8397-41e6-9d19-3415176714ad" class="numbered-list" start="8"><li>Carryover addition in other bases:<ul id="b5126de8-947a-4076-bfb9-fbecccc1e99b" class="bulleted-list"><li style="list-style-type:disc">In decimal, we take carry overs using 10. Say we have to put 69 in 1 place, we do 69-10=59-10=49-10=39-10=29-10=19-10=9(we subtracted 6 times)</li></ul><ul id="44e2a1f8-84d4-4afb-b43a-94589cae4dc1" class="bulleted-list"><li style="list-style-type:disc">So we have 9 and 6 as carry over</li></ul><ul id="c7db05fa-059d-4f4d-b877-54980132240f" class="bulleted-list"><li style="list-style-type:disc">If we have (575)8+(577)8 = (1374)8</li></ul><ul id="e556e2be-3161-40ef-96bd-7f14b20440fa" class="bulleted-list"><li style="list-style-type:disc">(11011)2+(11111)2 = 111010</li></ul></li></ol><ol type="1" id="8686217b-331b-4f55-8292-fa596f57f0ce" class="numbered-list" start="9"><li>For subtraction, we add 10 instead of subtracting, and in the next top number, he subtracts 1(-ve carry over)</li></ol><ol type="1" id="10e9a977-d275-4d68-8d0a-b6a7993ba1bf" class="numbered-list" start="10"><li>(1000)2-(0111)2 = 0001 (1A5)16-(296)16=-10F(-cause we don’t have another digit to carry over from)</li></ol><ol type="1" id="288dd592-4d26-44ea-859d-f57b0cf25cfb" class="numbered-list" start="11"><li>For going from decimal to some other base, we use the HCF method and take reminders as digits</li></ol><ol type="1" id="949bc974-92fb-4cd8-8afa-5cb1b18fa8f2" class="numbered-list" start="12"><li>13/2-&gt;6(1)-&gt;3(0)-&gt;1(1)-&gt;1 ===1101</li></ol><ol type="1" id="3ab0d946-2f42-4df4-887c-dcfbadecdec9" class="numbered-list" start="13"><li>For decimals, say 15.25, we do 15 separately, and then for after the point, we take 0.25 and use multiplication<ul id="cfb2e61a-7bab-4cd5-ae43-cc77f9edd1ab" class="bulleted-list"><li style="list-style-type:disc">0.25*2 -&gt; 0.5 0</li></ul><ul id="aea05691-9d6f-49ce-ab3a-040a3b771c3b" class="bulleted-list"><li style="list-style-type:disc">0.50*2 -&gt; 1.0 1</li></ul><ul id="410e1ce3-c019-40da-ac41-09efa258c220" class="bulleted-list"><li style="list-style-type:disc">0.00*2 -&gt; 0.0 We STOP</li></ul><ul id="efb1f108-eeb2-4655-b888-fccd72d12124" class="bulleted-list"><li style="list-style-type:disc">1’s decimal is 0.0, and so we have 0.0*2 = ,0, and we stop here</li></ul><ul id="212461d6-3d0b-40bf-ba54-3cb11833685c" class="bulleted-list"><li style="list-style-type:disc">For 15, we have 1111</li></ul><ul id="1b4d0f9a-2c4b-4772-bacf-8a12f901a0b8" class="bulleted-list"><li style="list-style-type:disc">The final answer is 1111.01</li></ul></li></ol><ol type="1" id="6d30a139-3cfb-4245-ac3d-c1e07c899a93" class="numbered-list" start="14"><li>NOTE- 1’s complement is binary with 0s replaced with 1s and 1s replaced with 0s, here if MSB is 1 then -ve else +ve :)</li></ol><ol type="1" id="81b4ced0-6530-4ec4-b970-40ff6727ca5c" class="numbered-list" start="15"><li>2’s complement is 1’s complement +1(in binary)</li></ol><ol type="1" id="6aadd5d5-75cd-4250-aa49-0a13c7db5ee0" class="numbered-list" start="16"><li>The range of unsigned binary numbers is from 0 to (2^n-1)</li></ol><ol type="1" id="1ad29df4-a13f-4a3c-9b37-fe6f523f51a6" class="numbered-list" start="17"><li>Signed numbers contain an extra bit called MSB(rightmost)- Most significant bit which represents (-1)^a if the number is abc and so this will give a sign</li></ol><ol type="1" id="4e9ed2c5-80ff-45b8-817f-0110eb46c231" class="numbered-list" start="18"><li><figure id="79a73f1f-c644-48f0-9bc5-fcc745718758" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image3.png"><img style="width:600px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image3.png"/></a></figure></li></ol><ol type="1" id="ad7b9eb1-1ea8-48b0-bd58-c79fa12eb168" class="numbered-list" start="19"><li><strong>Signed Magnitude form</strong><ol type="a" id="53601a86-d595-4d7e-8970-7360271e3756" class="numbered-list" start="1"><li>We have 2 representations of 0 and then we have x+(-x) != 0</li></ol><ol type="a" id="18176b38-209c-4f68-9b5f-d19c324f50f7" class="numbered-list" start="2"><li>1 101 is -5 and 0 101 is 5</li></ol><ol type="a" id="d48e5611-d2ea-4433-b127-e15140851ec2" class="numbered-list" start="3"><li>1 0000101 is -5 and 0 0000101 is 5</li></ol><ol type="a" id="5909c7dd-6efc-4955-8f0a-eef2c66d90cb" class="numbered-list" start="4"><li>Range is -(2^(n-1)-1) to (2^(n-1)-1)</li></ol></li></ol><ol type="1" id="a4eb8224-7ee7-460b-97b6-ce387e7037da" class="numbered-list" start="20"><li><strong>1’s complement</strong> method is just a case where we flip all the bits and MSB is 0 for +ve and 1 for -ve<ol type="a" id="745f8c47-f24e-46ec-967d-449b3126a911" class="numbered-list" start="1"><li>here if 0 010 is 2 and 1 101 is -2</li></ol><ol type="a" id="ce74e28c-a453-4b74-bada-76bbae61517a" class="numbered-list" start="2"><li>X+0 != X if we use -0, i.e. 5+(-0)=4</li></ol><ol type="a" id="1a9e04c0-4a97-4e68-8626-1147117313a8" class="numbered-list" start="3"><li>Range is -(2^(n-1)-1) to (2^(n-1)-1)</li></ol></li></ol><ol type="1" id="5667cb45-5800-4d15-b792-791f720f6104" class="numbered-list" start="21"><li><strong>2’s complement</strong><ol type="a" id="5d6587d9-91c3-4fdc-999e-6be571b18bd8" class="numbered-list" start="1"><li>2’s complement is 1’s complement + 1</li></ol><ol type="a" id="8e623d23-ceba-4d09-8dd2-2a82a78e4452" class="numbered-list" start="2"><li>So in this case if x is 0101 then -x is 1010+1=1011</li></ol><ol type="a" id="913fd32f-00cb-4550-88b6-ef4d4a232aeb" class="numbered-list" start="3"><li>If x is 0110 which is 6 then -x is 1001+1= 1010 which is -6</li></ol><ol type="a" id="4e8eb2b2-2ab9-4362-818f-101e4117bd40" class="numbered-list" start="4"><li>Range is -2^(n-1) to (2^(n-1)+1)</li></ol><ol type="a" id="84d1d9ea-4ece-4836-93c6-55f19510e1b8" class="numbered-list" start="5"><li>If we are doing a-b = a+(-b) = a+(2’s complement of b)</li></ol></li></ol><h1 id="e1b0a006-ab86-4967-9ad7-0b1008ce560c" class="">C Programming</h1><h3 id="0cc8e7db-0278-400c-9289-2051aa8fd991" class="">Basics</h3><ul id="d28c30cd-41da-4a2a-88c9-4c49f1136d11" class="bulleted-list"><li style="list-style-type:disc">Product Code using scanf and printf</li></ul><ul id="d3a99889-a9dd-4bfe-9591-59a4cfc0c20c" class="bulleted-list"><li style="list-style-type:disc">User-defined functions</li></ul><ul id="6a1853cf-0791-4619-b2d5-802c16138860" class="bulleted-list"><li style="list-style-type:disc">gcc file.c -lm</li></ul><ul id="d0b80dd5-6922-43b4-8de6-fe98fce1be69" class="bulleted-list"><li style="list-style-type:disc">./a.out</li></ul><ul id="6b31bb7d-33c6-412f-9cdf-2d44c6075a84" class="bulleted-list"><li style="list-style-type:disc">Function call -&gt; func();</li></ul><ul id="6c88d504-5728-4ae4-a508-c5ffdf96ad69" class="bulleted-list"><li style="list-style-type:disc">Try to call from another function</li></ul><figure id="42fdfb4e-437b-41c9-8e60-5e96e601bf92" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image27.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image27.png"/></a></figure><h3 id="672dcd2a-a79a-4c22-9d40-f8cbd8d7e585" class="">Rules</h3><ul id="75aca890-8a14-49ec-8ce3-1cd2240867bc" class="bulleted-list"><li style="list-style-type:disc">Use good meaningful names</li></ul><ul id="2696fe6a-d59f-4628-8655-67854072e8ab" class="bulleted-list"><li style="list-style-type:disc">Use indents and whitespaces</li></ul><ul id="d3fb5060-38ab-489a-a53b-6249c401f800" class="bulleted-list"><li style="list-style-type:disc">Use blank lines</li></ul><ul id="600cf25e-421c-4e5e-9674-0c863c421807" class="bulleted-list"><li style="list-style-type:disc">Do not duplicate tests</li></ul><ul id="fb32af7d-ee29-4e65-a011-9282f7575c9e" class="bulleted-list"><li style="list-style-type:disc">Use Parentheses</li></ul><ul id="ec897062-ba0f-4491-8a1d-69781f5db02c" class="bulleted-list"><li style="list-style-type:disc">Use semicolon</li></ul><h3 id="2804ac8c-a9bb-4389-b1f1-a516c4a83fb9" class="">Character Set</h3><ul id="0161b8ff-dd4f-45ec-9d94-0c07b0190901" class="bulleted-list"><li style="list-style-type:disc">Alphabets<ul id="16551e22-6261-4832-8fd7-200023640de1" class="bulleted-list"><li style="list-style-type:circle">If abcdefgh is the string:</li></ul><ul id="29943467-59f1-455e-8a2a-5123efbf2c1d" class="bulleted-list"><li style="list-style-type:circle">%s will print abcdefgh</li></ul><ul id="621c9a44-f4b9-46eb-9a27-68281321db30" class="bulleted-list"><li style="list-style-type:circle">%.3s will print abc</li></ul><ul id="5a3b25d1-58dd-4987-8d19-e4288f5d51c6" class="bulleted-list"><li style="list-style-type:circle">%-15.8s will print abcdefgh_ _ _ _ _ _ _</li></ul><ul id="b116bd6d-2f3a-4836-a0d4-ab2e53915855" class="bulleted-list"><li style="list-style-type:circle">%15.7s will print _ _ _ _ _ _ _ _abcdefg</li></ul></li></ul><figure id="945fe01f-bde2-425a-85bc-f466cec57af2" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image19.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image19.png"/></a></figure><ul id="05c1940b-98fe-4135-b761-5dcd769a0963" class="bulleted-list"><li style="list-style-type:disc">Digits<ul id="6fa255cb-55d7-4b72-b137-f060497d4836" class="bulleted-list"><li style="list-style-type:circle">While printing, use %5.2 prints two decimal places and a total of 5 spaces</li></ul><ul id="88203647-cfb7-41bc-b7b1-cf8709efe21e" class="bulleted-list"><li style="list-style-type:circle">_ _ . _ _</li></ul><ul id="c14833b4-1205-47b3-9e8f-0103b5e17f32" class="bulleted-list"><li style="list-style-type:circle">Same for characters also</li></ul></li></ul><ul id="27ae6078-cd64-4d12-a814-ed4467064c64" class="bulleted-list"><li style="list-style-type:disc">Special Symbols<ul id="d99fcd0c-2851-4fcb-a289-d3bc1c54f1bb" class="bulleted-list"><li style="list-style-type:circle">\r replaces the prev text and starts from 0, starts from the start of the line</li></ul><ul id="c02f09e3-8c19-4965-bad6-d05f738a0105" class="bulleted-list"><li style="list-style-type:circle">We only print till printf encounters \0</li></ul></li></ul><ul id="999c645a-4876-443d-a4d4-2b56a2ae348c" class="bulleted-list"><li style="list-style-type:disc">White spaces-blank()</li></ul><h3 id="b80d61bb-142d-4541-b7e6-67ab86866595" class="">Format Specifiers</h3><ul id="71683508-b772-40c8-8c04-866df8375612" class="bulleted-list"><li style="list-style-type:disc"><strong>A period (.) – Separates field width and provides precision.</strong></li></ul><ul id="9933fa53-16dc-4a09-9030-c429f8d7f191" class="bulleted-list"><li style="list-style-type:disc"><strong>A minus symbol (-) – Provides left alignment for the value.</strong></li></ul><ul id="de4a97b5-7f32-4feb-9206-4016e36d197d" class="bulleted-list"><li style="list-style-type:disc"><strong>A number after the ‘%’ to specify the minimum width of the string to be printed.</strong></li></ul><figure id="c008bede-8a46-4659-85d6-e8f1d2ac6164" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image5.png"><img style="width:458px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image5.png"/></a></figure><h3 id="c6bd0162-a941-4001-9f7c-f4b856c32af4" class="">C tokens</h3><ul id="0a10bc5f-a41b-482e-ba4e-a6d4aad79d75" class="bulleted-list"><li style="list-style-type:disc">Smallest individual unit or lexical units</li></ul><ol type="1" id="b0c27552-3c3f-4ae3-bb6f-7529ea2dfdc6" class="numbered-list" start="1"><li>Naming of variables<ol type="a" id="7a6a0ccb-a8bd-4c95-b779-d23370a555b0" class="numbered-list" start="1"><li>The first can only be a letter or underscore only</li></ol><ol type="a" id="e7ca1f61-2713-49f6-824f-d25a6f571e52" class="numbered-list" start="2"><li>Only letters, digits, or underscores</li></ol><ol type="a" id="3d3a5159-380a-4848-9384-6b93e061e6dd" class="numbered-list" start="3"><li>Cannot be reserved words</li></ol></li></ol><ol type="1" id="866686d3-d581-4ccc-bce7-479168b4e20f" class="numbered-list" start="2"><li>Operators/sizeOf</li></ol><ul id="13190bcd-c46f-4a6a-9780-2eddb6c2075c" class="bulleted-list"><li style="list-style-type:disc">An expression doesn&#x27;t get evaluated inside the sizeof operator.</li></ul><ul id="9d92ede0-9ae7-4f42-a384-8fe0f0459a79" class="bulleted-list"><li style="list-style-type:disc">sizeof(‘3’) gives 4 as it gets converted to int - In C type of character constant Like &#x27;3&#x27; or even ‘a’ is int.</li></ul><ul id="e7f4e552-2eae-4ec9-9bbb-9d78bd86e7c5" class="bulleted-list"><li style="list-style-type:disc">sizeof(&quot;3&quot;) gives 2 as 3 + \0</li></ul><ul id="20085d70-7909-4960-9cbb-4c4cb5599b44" class="bulleted-list"><li style="list-style-type:disc">We can swap two variables without any extra variable using the bitwise XOR operator &#x27;^&#x27;. Let X and Y be two variables to be exchanged. Following the steps, swap X and Y.</li></ul><ul id="b0c75ef5-b7b9-4e9a-a758-cbc101a44757" class="bulleted-list"><li style="list-style-type:disc">X = X ^ Y;</li></ul><ul id="460103dc-1a4d-43e4-8569-588d40d77ce6" class="bulleted-list"><li style="list-style-type:disc">Y = X ^ Y;</li></ul><ul id="8eaa7dca-428d-4b84-8c71-59e2f6b09d1b" class="bulleted-list"><li style="list-style-type:disc">X = X ^ Y;</li></ul><ul id="b45ae096-890a-4c4d-8df9-2b84e861c870" class="bulleted-list"><li style="list-style-type:disc">Bitwise &lt;&lt; multiplies number by 2^x</li></ul><ul id="20edb8cf-766d-46a0-b845-b7ddb10d3fd2" class="bulleted-list"><li style="list-style-type:disc">Bitwise &gt;&gt; divides the number with 2^x</li></ul><ul id="e50f71f4-7720-4568-8b9a-8515b425c3f7" class="bulleted-list"><li style="list-style-type:disc">- a is same as a=a-1 same as a-=1</li></ul><h3 id="767d708b-ac4e-4aa3-8370-9891a27b3210" class="">Comma Operator</h3><ul id="5dc2bca2-b868-4502-a9ff-23e396fdb3e0" class="bulleted-list"><li style="list-style-type:disc">int x = (5, 6); it first becomes x then becomes 6</li></ul><ul id="f95cfdcb-df16-481a-b09f-5a1a0ebdf7c0" class="bulleted-list"><li style="list-style-type:disc">int i = 2, 3, 4; ERROR</li></ul><ul id="11536678-e12d-4707-b231-0953d1cb94ff" class="bulleted-list"><li style="list-style-type:disc">Int i; i=2, 3, 4; NO ERROR and takes 2</li></ul><h3 id="444d9913-f401-4bff-8f1b-a694d7f2322f" class="">Increment and decrement Operator</h3><ul id="e81c99b3-8092-43d8-a7b4-f96872b419e6" class="bulleted-list"><li style="list-style-type:disc">Prefix and postfix, prefix happens together</li></ul><ul id="bca126db-a8af-4ae9-a969-a6ce9e63968b" class="bulleted-list"><li style="list-style-type:disc">Postfix doesn’t happen until after the statement</li></ul><ul id="68c34ea9-1dd5-4f0c-aced-a9dbcf333ace" class="bulleted-list"><li style="list-style-type:disc">3++ and 4++ are not possible cause you can’t do 3=3+1, so will get lvalue error</li></ul><h3 id="b77c942a-d93d-4509-a6d3-5a9e178c62bc" class="">Operator Precedence:</h3><ol type="1" id="833e0104-022c-4016-9699-fa68139458b4" class="numbered-list" start="1"><li>() function call and array reference [] L-&gt;R</li></ol><ol type="1" id="886436b9-feaf-48b5-b728-8c7566930d05" class="numbered-list" start="2"><li>++ - - | sizeof R-&gt;L</li></ol><ol type="1" id="19d9e913-6abf-4e2c-a288-f5a03dacad52" class="numbered-list" start="3"><li>/ % L-&gt;R</li></ol><ol type="1" id="327cd3a1-f5cb-4123-8c2c-c42ebe2976c7" class="numbered-list" start="4"><li>+ - L-&gt;R</li></ol><ol type="1" id="d04af469-4041-4fcc-9a0d-cf3d9e2fd306" class="numbered-list" start="5"><li>&lt; &lt;= &gt; &gt;= L-&gt;R</li></ol><ol type="1" id="7934d4f0-8ed3-47ff-b211-9b2b6c7c9b9c" class="numbered-list" start="6"><li>== != L-&gt;R</li></ol><ol type="1" id="a89c3a15-e51d-4bc0-9e0a-e2237dfc2d68" class="numbered-list" start="7"><li>&amp;&amp; L-&gt;R</li></ol><ol type="1" id="2c284e6c-9e0f-44f2-82a6-377898e8329b" class="numbered-list" start="8"><li>|| L-&gt;R</li></ol><ol type="1" id="d013a0d8-cecd-4558-bca8-e154f0027812" class="numbered-list" start="9"><li>= += -= *= /= %= R-&gt;L</li></ol><ol type="1" id="12385d8b-ef27-4556-b62d-cbcad3e5ea4e" class="numbered-list" start="10"><li><strong>printf executes from Right to Left, but it’s like, it goes from right to left, does the operations and prints only for post operators and then prints others</strong></li></ol><ol type="1" id="7a3d6f2a-e914-4c39-b465-33444c08c178" class="numbered-list" start="11"><li><strong>int i=0; printf(&quot;%d %d %d&quot;, i++ , ++i, i++);</strong></li></ol><ul id="99058a51-ac98-49b3-a33c-b0df4ee7794a" class="bulleted-list"><li style="list-style-type:disc"><strong>In this case, i++ is executed and printed so 0 but i=1</strong></li></ul><ul id="ad602e5c-a2de-44e7-a4f3-00d8db6d46cd" class="bulleted-list"><li style="list-style-type:disc"><strong>++i becomes 2 but is not printed</strong></li></ul><ul id="560ed99a-01f8-4b42-9092-43efb6d41607" class="bulleted-list"><li style="list-style-type:disc"><strong>i++ is executed prints 2 becomes 3</strong></li></ul><ul id="e2b6298d-dab7-4a59-b2ed-9a7baeda558e" class="bulleted-list"><li style="list-style-type:disc"><strong>So the output should be 2 3 0</strong></li></ul><ul id="2744284b-2a8e-411d-ac92-f419d07dbffd" class="bulleted-list"><li style="list-style-type:disc"><strong>NOTE: Won’t work with scanf, it’ll execute directly only</strong></li></ul><figure id="b11001c5-72ed-42ba-b1c4-68ed7701e06f" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image30.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image30.png"/></a></figure><h3 id="4dc67f44-ad0a-4aa7-aaea-b1cf0f6aa5a7" class="">Comparing Operators</h3><ul id="945738c0-b5ad-4ec7-a804-f970e39e4bf3" class="bulleted-list"><li style="list-style-type:disc">a||b won’t evaluate b if a is true</li></ul><ul id="1c2f5e0e-f760-45fc-96cc-2fceae2bd84f" class="bulleted-list"><li style="list-style-type:disc">a&amp;&amp;b won’t evaluate b if a is false</li></ul><figure id="7d2663d3-43b1-48d4-990c-ce85a1c95caa" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image34.png"><img style="width:172px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image34.png"/></a></figure><ul id="f20121bc-9c31-4426-acc9-4f4fd688d9df" class="bulleted-list"><li style="list-style-type:disc">The sign of % will be the sign of the first number</li></ul><ol type="1" id="8831c0fc-2b8d-4443-9e63-716b11b5f6ee" class="numbered-list" start="1"><li>printf and scanf<ol type="a" id="0c514688-a964-46c2-81a0-03e70714f376" class="numbered-list" start="1"><li>If we have scanf(&quot;%d %*d %d&quot;, &amp;a, &amp;b); and data is given as 123 456 789, then 123 is given to a and 456 is skipped cause of * and 789 is given to b</li></ol><ol type="a" id="acdd5d8d-06b8-4d33-8112-77e971861938" class="numbered-list" start="2"><li>scanf stops as soon as one of the variable’s datatypes doesn’t match</li></ol><ol type="a" id="7d72be56-0b7d-4aa6-9eed-531f23de096d" class="numbered-list" start="3"><li>printf(&quot;control string&quot;, arguments);</li></ol><ol type="a" id="5052a3e1-0d1c-4150-a96c-f1adbaed08ae" class="numbered-list" start="4"><li>In printf, if we give fewer arguments, it’ll print a garbage value</li></ol><ol type="a" id="69ce5ff4-094b-44b7-8ed0-7e37ebd3ed5d" class="numbered-list" start="5"><li>If we give too many arguments, that is <strong>too less format specifiers</strong>, it’ll print only till the format specs are done but will give a warning</li></ol><ol type="a" id="acbd2861-3943-4f49-92ac-2d66ea080f1b" class="numbered-list" start="6"><li>scanf returns the number of arguments it successfully took</li></ol><ol type="a" id="51e6e2ed-e76c-4132-a85a-5720851cad4a" class="numbered-list" start="7"><li>scanf(&quot;%[^\n]&quot;, &amp;sentence) will scan until new line</li></ol><ol type="a" id="7e40e723-7ff1-4990-8602-5d671816e1e8" class="numbered-list" start="8"><li>scanf(&quot;%[d]&quot;, &amp;sentence) will scan only if d is there</li></ol></li></ol><ol type="1" id="e39f1b5c-bcc6-4d3b-b8c9-a65eec686a94" class="numbered-list" start="2"><li>If else</li></ol><ul id="1f71a4d6-5713-4542-b3a2-e9d336613cfe" class="bulleted-list"><li style="list-style-type:disc">if(condition) {Statement;}</li></ul><ul id="478d98e5-7702-40ea-a781-eab78522587b" class="bulleted-list"><li style="list-style-type:disc">This will work, but if we have a ; in the first line, it won’t work as an if-else statement</li></ul><ul id="1c6398d7-5117-47dc-ae2f-0714ef5261d2" class="bulleted-list"><li style="list-style-type:disc">Else will pair up with the most recent unpaired if(Concept of dangling if)</li></ul><h3 id="30e8534f-583d-4d0b-a3f0-2f999e0b0484" class="">Conditional Operator</h3><ul id="813849ee-c6d8-4a4d-be44-982e4f68316e" class="bulleted-list"><li style="list-style-type:disc">Ternary operator</li></ul><ul id="6adbb417-64b4-4e0a-8d85-16965fde899f" class="bulleted-list"><li style="list-style-type:disc"><code>(exp1) ? (stat1) : (stat2);</code></li></ul><ol type="1" id="03d1700e-5025-4081-bfba-826131b8fcba" class="numbered-list" start="1"><li>Goto statements<ol type="a" id="38bb7eeb-59be-455a-b4a8-7b91b59a201b" class="numbered-list" start="1"><li>Unconditional jumps</li></ol><ol type="a" id="7ebe5f9a-df1f-4a2d-b7ee-93c513c03579" class="numbered-list" start="2"><li>Not a replacement for continue or break</li></ol></li></ol><ol type="1" id="c2d3ef36-9682-4c1d-965f-7ad0af1df136" class="numbered-list" start="2"><li>Switch Statement:<ol type="a" id="2ba959a2-8c64-4458-a87e-3cca636d4a4d" class="numbered-list" start="1"><li>If no break will execute everything after that case unless there’s a break</li></ol><ol type="a" id="f1efb3a9-bb48-43ed-b24b-1dddf5e5027b" class="numbered-list" start="2"><li><figure id="1e6cf87e-bd26-447c-8b2d-3d0461226030" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image24.png"><img style="width:317px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image24.png"/></a></figure></li></ol><ol type="a" id="a90f8084-e6a4-432e-b035-f240076e511f" class="numbered-list" start="3"><li>Switch won’t work with double</li></ol><ol type="a" id="cafa3204-a5a9-4879-af69-13b7b21b9345" class="numbered-list" start="4"><li><figure id="6d73719e-695b-4a3d-9ade-327e2fa3f177" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image36.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image36.png"/></a></figure></li></ol><ol type="a" id="c1f8491c-e801-4049-8384-645ed6ee4a8d" class="numbered-list" start="5"><li>Here since the default is in the start, that means it’ll still look for a break</li></ol><ol type="a" id="0b1c5573-d0ee-4395-86f8-ecf1080526f9" class="numbered-list" start="6"><li><figure id="b7418876-bb59-402b-8145-cd7f5108459d" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image35.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image35.png"/></a></figure></li></ol><ol type="a" id="fcf591d3-a88d-4473-b730-31202e22b90f" class="numbered-list" start="7"><li>Case statements can have everything except variables, even 1 &amp;&amp; 1 and 5 &amp;&amp; 5 but these give errors because both give the same value.</li></ol></li></ol><ol type="1" id="cbeb6bc8-6111-4937-b74b-ee35bf69d195" class="numbered-list" start="3"><li>Macros</li></ol><ul id="185fae50-f1f5-4498-ba22-8e5505d27479" class="bulleted-list"><li style="list-style-type:disc">#define and #include, not case sensitive(according to ANSI C)</li></ul><ul id="face82e4-646d-48cb-9049-1feb39dc9e2d" class="bulleted-list"><li style="list-style-type:disc"><code>#define sq(x) x*x</code><ul id="611bba4d-c8b0-4e89-86b6-afa7e4ccdfca" class="bulleted-list"><li style="list-style-type:circle">sq(4)=16</li></ul><ul id="9b5f85cc-2e94-4174-9e31-d86b021f09c7" class="bulleted-list"><li style="list-style-type:circle">sq(4/2)=4</li></ul><ul id="c60ec35a-d585-4afa-917f-f1afc146d2e8" class="bulleted-list"><li style="list-style-type:circle">sq(1+2)=1+2*1+2=5</li></ul></li></ul><ul id="d983ded0-be64-41c6-89ae-f179482054fa" class="bulleted-list"><li style="list-style-type:disc">Remember no semicolon in the end for a macro</li></ul><ul id="070bec1d-1649-4c15-b30d-ea390187b8f3" class="bulleted-list"><li style="list-style-type:disc">And since macro directly replaces, we can’t have x++ and stuff like that with x being replaced by a constant</li></ul><ul id="7a1bb7c7-479e-4dcb-9fb1-73097ae28006" class="bulleted-list"><li style="list-style-type:disc">After the pre-processing is over, all the undefined macros are initialized with the default value of 0. If macro X has not been defined, it is initialized with 0.</li></ul><h3 id="ae3e7cd0-28cd-4c4c-bd30-fd424deaf3e5" class="">Loops</h3><ul id="47fad376-a9bd-4b4b-a04f-c9835437a6ba" class="bulleted-list"><li style="list-style-type:disc">While loop</li></ul><ul id="8937c81d-2d44-4eda-80e1-3d51f7f1a4a5" class="bulleted-list"><li style="list-style-type:disc">Do while</li></ul><ol type="1" id="51d8d9c2-78c6-433c-8a0a-ae1360ceb941" class="numbered-list" start="1"><li>Runs at least once</li></ol><ul id="b66f857d-4a41-4f91-96a1-7b25d1f660d6" class="bulleted-list"><li style="list-style-type:disc">For loop</li></ul><ul id="058999f3-1d96-4f99-9335-d4d1ac2f9722" class="bulleted-list"><li style="list-style-type:disc"><code>for(int i=0; i&lt;=10; i++)</code></li></ul><ul id="f52bb073-ab42-4280-bf1b-31333daa7f2b" class="bulleted-list"><li style="list-style-type:disc">We can put any number of statements before; in the for loop</li></ul><ul id="0fb18858-435b-44b7-99de-0a01ef485504" class="bulleted-list"><li style="list-style-type:disc">Only last one will be considered but</li></ul><figure id="e29c40b0-c569-40e9-b97b-b33ef003b000" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image20.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image20.png"/></a></figure><ul id="b7c93961-8c0b-41a8-92a7-f18ee6c70dca" class="bulleted-list"><li style="list-style-type:disc">int need not be inside for, but the variable will be under local scope if int is there, else no</li></ul><ul id="40d80886-7561-42f2-838e-20b4de4e09ea" class="bulleted-list"><li style="list-style-type:disc"><figure id="0c247819-f622-44d7-a628-02d0fabad8e5" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image31.png"><img style="width:459px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image31.png"/></a></figure><figure id="6e3fb561-9f5b-4d08-8aad-8b009d0433ff" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image23.png"><img style="width:519px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image23.png"/></a></figure></li></ul><ul id="83b5860d-a909-48ff-af9b-401dd4350c7a" class="bulleted-list"><li style="list-style-type:disc">A unique aspect of for loop is that some sections can be omitted for(; m!= 100 ;)</li></ul><ul id="d25d025a-59cf-48de-a897-52a484eaef51" class="bulleted-list"><li style="list-style-type:disc">We can put time delay loops by for(j=1000; j&gt;0; j–);</li></ul><h3 id="7fb15493-1606-4d74-af54-e275bead3a82" class="">Arrays and other data structures</h3><ul id="abdef1a9-5d76-405b-aca8-a2a0036e4153" class="bulleted-list"><li style="list-style-type:disc">Arrays start with 0</li></ul><ul id="6c4913c1-bd44-4c8d-bf82-7eb7fd24db7f" class="bulleted-list"><li style="list-style-type:disc">float height[10]</li></ul><ul id="211434bc-a050-4b87-a481-863ecf8583b6" class="bulleted-list"><li style="list-style-type:disc">int group[10]</li></ul><ul id="359fc130-5dae-4317-82fc-8d725aeb558d" class="bulleted-list"><li style="list-style-type:disc"><strong>type array-name[size] = {list of values}</strong></li></ul><ul id="c04f69e8-8522-4d54-a332-24acb83dbe49" class="bulleted-list"><li style="list-style-type:disc">int num[3] = {0, 0, 0};</li></ul><ul id="f6b01821-4f89-445d-a203-4d4c164ef899" class="bulleted-list"><li style="list-style-type:disc">int counter[] = {1, 1, 1, 1};</li></ul><ul id="8f7ce527-e679-4ed3-8526-396b47be73c2" class="bulleted-list"><li style="list-style-type:disc">int number[3] = {10, 20, 30, 40}; <strong>Will give warning</strong></li></ul><ul id="37e212a2-f0b9-47ee-b2cf-6c8205d7be97" class="bulleted-list"><li style="list-style-type:disc">Data types -&gt; Int/Float/Char and when we go to user-defined data types we have structs/unions and enums</li></ul><ul id="ffc7ae92-cb3b-4f2a-a4c2-6896334e703b" class="bulleted-list"><li style="list-style-type:disc">Derived data types include arrays, functions, and pointers</li></ul><ul id="02bf8c81-96bd-44ce-8c46-abb6b4e612f4" class="bulleted-list"><li style="list-style-type:disc">Arrays are homogeneous, all are of the same type</li></ul><ul id="364affde-c708-4a8f-b477-597979fafaa6" class="bulleted-list"><li style="list-style-type:disc">If we try to access an array out of its bounds, it might give <strong>warnings and print garbage value/0</strong></li></ul><ul id="eb6a1ab9-43c3-48ea-888e-d195784ae90a" class="bulleted-list"><li style="list-style-type:disc">Have to declare elements initially only if you are using {/}</li></ul><ul id="4c33e102-dd7b-409e-83db-2872c03deae5" class="bulleted-list"><li style="list-style-type:disc"><figure id="4fa87e5b-5484-4ce5-b082-c9d486dcc05d" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image32.png"><img style="width:527px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image32.png"/></a></figure></li></ul><ul id="a9b918a1-99d5-4863-951e-81f1e17d5884" class="bulleted-list"><li style="list-style-type:disc">If we have <code>int max[5] = {8, 7};</code></li></ul><ul id="17300298-5a5b-455d-8c10-df5bb248195c" class="bulleted-list"><li style="list-style-type:disc">When we print the array we get 8 7 0 0 0 5 -1076194544 -1076194544(the last 3 are garbage values)</li></ul><ul id="a01e2128-2a3f-4ebd-afe9-36127f4a4ef2" class="bulleted-list"><li style="list-style-type:disc">If we have <code>static int max[5] = {8, 7}</code>, we get 8 7 0 0 0 0 0 0</li></ul><ul id="852db266-5a67-4ee1-9d47-d9ed4a56d520" class="bulleted-list"><li style="list-style-type:disc">When we pass arr to another function and try to find size, it becomes pointer</li></ul><ul id="f676d083-05d5-4c25-b814-37299e4f2fed" class="bulleted-list"><li style="list-style-type:disc">Static arrays exist but static arrays with variable size do not exist</li></ul><h3 id="6404148a-e6de-47da-8edd-2cae760669b6" class="">Precedence of Array references</h3><h3 id="1835b5d8-c241-4b4c-8117-12c650bcc077" class="">User-defined functions</h3><ul id="1ca8ec27-00c0-421e-9535-eb5b128b7425" class="bulleted-list"><li style="list-style-type:disc">If we want to use the function which is declared later, we need to prototype declare it.</li></ul><ul id="3543d61d-e27d-48f8-b34b-b1440a6201fa" class="bulleted-list"><li style="list-style-type:disc">We use return statements to return a value to the place the function is called.</li></ul><ul id="6f621cba-6b81-41da-8acd-72b6c78a9393" class="bulleted-list"><li style="list-style-type:disc">Using arguments: function(i, j); ← actual arguments</li></ul><ul id="4ecbb29c-1cdf-46ca-9a95-a5051ce67ecc" class="bulleted-list"><li style="list-style-type:disc">Else we call directly the function without any arguments</li></ul><ul id="1f3b33b6-2b08-4d09-857c-b8acce1e3927" class="bulleted-list"><li style="list-style-type:disc">In function declarations, we have function(int i, int x); ← this is formal arguments</li></ul><h3 id="bcc2a22b-adc4-4b07-bcd0-e62d82df14bc" class="">Parameter Passing in C</h3><ul id="624ae78e-ed86-44b4-81e2-ff2b30fc173d" class="bulleted-list"><li style="list-style-type:disc">Call by value means a copy of the data is made and stored as the parameter and any change is not affecting the actual variable</li></ul><ul id="7c9924c3-e632-4bf6-94eb-99af694de688" class="bulleted-list"><li style="list-style-type:disc">For call by reference, we have two types:<ul id="0fd413d0-1d8d-4031-9384-5598ca9fe92f" class="bulleted-list"><li style="list-style-type:circle">Arrays are passed by reference in C. Any change made to the parameter containing the array will change the value of the original array.</li></ul><ul id="4482796c-51e8-4471-92a3-301f9c677f9d" class="bulleted-list"><li style="list-style-type:circle">Ampersand was used in the function prototype.</li></ul><ul id="c3a0dc62-fdbd-4864-92bf-613bc81a2603" class="bulleted-list"><li style="list-style-type:circle">We use *variable_name in the function for formal argument but then while calling it we use &amp;s and not *s</li></ul><ul id="483f85bf-7bc4-4d9c-9f71-a70af886215c" class="bulleted-list"><li style="list-style-type:circle">TRUCK is important, not TRACK :)</li></ul><ul id="f2d938df-9692-4c23-b227-e06bf9cb6640" class="bulleted-list"><li style="list-style-type:circle">Nikumani Sir House -&gt; H113 H2/101</li></ul><ul id="52ccce8d-da21-46c1-b917-129c2af263dc" class="bulleted-list"><li style="list-style-type:circle">For arrays, we don’t have to use call by reference extra, because if int a[SIZE]; is an array, a gives the address of the array anyway.</li></ul><ul id="1d665964-ed05-4e5b-894e-99e7284507ea" class="bulleted-list"><li style="list-style-type:circle">WE can return multiple values from functions indirectly but directly we can only return one value</li></ul><ul id="406b5038-c199-4522-bfee-74b84743dd70" class="bulleted-list"><li style="list-style-type:circle">We can use arrays and pointers, take a few of these extra and return through these.</li></ul><ul id="47fab74c-cdaa-48dc-a53b-edd85e9bc536" class="bulleted-list"><li style="list-style-type:circle">NOTE: If we print function without (), gives address or garbage value</li></ul></li></ul><h3 id="c28d6daa-4ce9-4f8a-966a-1f8bf0e1e9c3" class="">Recursion</h3><ul id="2b97b1f1-240a-4395-b18f-016069589f83" class="bulleted-list"><li style="list-style-type:disc">Calling a function from its own function</li></ul><ul id="aefd5525-0fb8-4c5f-a824-0bea97c56162" class="bulleted-list"><li style="list-style-type:disc">fac(n) = n*fac(n-1) idk coding bro why attack</li></ul><ul id="62b78933-fa23-45d8-ae4b-795cce41af44" class="bulleted-list"><li style="list-style-type:disc">fib(n) = fib(n-1)+fib(n-2)</li></ul><ul id="6ca5d397-71f5-4739-b9f7-8f2c7ef0ee93" class="bulleted-list"><li style="list-style-type:disc">If we draw a stack for fac(3) it’ll be like</li></ul><ul id="bf43a83f-b316-4db1-ba39-9c2b24cd0084" class="bulleted-list"><li style="list-style-type:disc">f(0)</li></ul><pre id="ff14dcf1-f3de-42ea-9dcc-f6a2ed3aa293" class="code"><code>f(1)
f(2)
f(3)</code></pre><ul id="53527398-d891-4076-9e66-dbe3f64d0ccf" class="bulleted-list"><li style="list-style-type:disc">Now here f(0) returns value to f(3) and since the stack is LIFO, the last one to go in should be the first one to come out</li></ul><ul id="378b710f-06fe-4cc5-a756-e8c46f158b28" class="bulleted-list"><li style="list-style-type:disc">If someone asks how to avoid stack overflow, don&#x27;t say increase the size of the stack</li></ul><ul id="9f948984-0ff8-4a58-9279-81bf6062a9c2" class="bulleted-list"><li style="list-style-type:disc">Stack is not LITE</li></ul><ul id="463a109a-3a9b-46e5-a13d-1f45c3a85075" class="bulleted-list"><li style="list-style-type:disc">Used heavily in tree traversals and in data structures and divide and conquer models</li></ul><h3 id="d65b32ab-7223-4070-9aa5-5855f3e6ee8e" class="">1D Arrays</h3><ul id="55788e8b-4b55-4ea8-9663-2b2110cff7a2" class="bulleted-list"><li style="list-style-type:disc">int a[10];</li></ul><ul id="e3f17aeb-d16f-442d-9de5-97a9ac4e264f" class="bulleted-list"><li style="list-style-type:disc">a++ gives address of a[1]</li></ul><ul id="8efafe0e-6057-4586-a77b-2d9df3e1d9eb" class="bulleted-list"><li style="list-style-type:disc">a gives address of array and that of a[0]</li></ul><ul id="8f913d96-a511-4d53-a063-2b6cbe0d529c" class="bulleted-list"><li style="list-style-type:disc">a+1 will add 1 to value at a[0]</li></ul><ul id="fb7df46f-3988-48ca-bac4-4dadd7cffbfa" class="bulleted-list"><li style="list-style-type:disc">(a+1) will print a[1]</li></ul><ul id="2a2bad15-e385-47c0-8313-3ca654beace1" class="bulleted-list"><li style="list-style-type:disc">marks[i] -&gt; *(marks+i) -&gt; *(i+marks) -&gt; i[marks]</li></ul><ul id="2cb561bd-a5fe-4b72-9129-3b57f355bc57" class="bulleted-list"><li style="list-style-type:disc">If the size of the array is variable, it can’t be initialized</li></ul><ul id="370212ed-35e2-4b4b-99bd-7534c04ddb2c" class="bulleted-list"><li style="list-style-type:disc">Size variable for array can’t be outside function</li></ul><pre id="594f73e9-b13b-44cb-9fad-8250d5d9a759" class="code"><code>#include &lt;stdio.h&gt;

int main(){
    int arr[5] = {6, 18, 10, 12, 16};

    int *pointer = &amp;arr;

    printf(&quot;Array address: %d\n&quot;, arr);

    printf(&quot;Array address: %d\n&quot;, &amp;arr);

    printf(&quot;Array address: %d\n&quot;, &amp;arr[0]);

    printf(&quot;Array Value: %d\n&quot;, arr[0]);

    printf(&quot;Address of third index: %d\n&quot;, arr+3);

    printf(&quot;Array Value at 3rd pos: %d\n&quot;, *(arr+3));

    printf(&quot;Array[0]+3: %d\n&quot;, *arr+3);

    printf(&quot;Address of array: %d\n&quot;, &amp;arr+1);
}</code></pre><h3 id="2d657011-4c94-44bb-af0a-c2fa514f5d7a" class="">2D Arrays</h3><ul id="5fd8d8f8-87ba-44b0-9884-114c4790e721" class="bulleted-list"><li style="list-style-type:disc"><strong>type array_name[row_no][col_n0]</strong>;</li></ul><ul id="180679c4-d8cb-4495-b71b-0402100ca309" class="bulleted-list"><li style="list-style-type:disc">int[5][12] last element will be indexed at 4,11</li></ul><ul id="1bf1297b-b456-4acd-a898-6cac038ca8f6" class="bulleted-list"><li style="list-style-type:disc">If the array is completely initialized, that is it has a value row-wise in {} then we don’t have to specify the number of rows</li></ul><ul id="ff94fb68-55f4-43e7-b5dd-928413f06787" class="bulleted-list"><li style="list-style-type:disc">If it’s written in one row only we need to specify both the dimensions</li></ul><ul id="2bb4d5d8-6e7f-4caf-ae91-84180b3fee03" class="bulleted-list"><li style="list-style-type:disc">int table[4][3] = {{2, 5, 6}, {9, 3, 5}, {1, 7, 2}, {3, 0, 5}};</li></ul><ul id="d163378a-a260-43b8-8f77-6bb4b0c77e8e" class="bulleted-list"><li style="list-style-type:disc">int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};</li></ul><ul id="e2230018-3df8-49d3-bf91-bcb18b9d112e" class="bulleted-list"><li style="list-style-type:disc">If we initialize and miss a number, it’s automatically initialized to 0</li></ul><ul id="44a901a2-e010-4637-bc4a-793c74577edc" class="bulleted-list"><li style="list-style-type:disc">Here if we have a[m][n], a will point to first element of array and a+1 will point to the element after n</li></ul><ul id="9446d0e6-6624-446b-b124-49092d97e8cb" class="bulleted-list"><li style="list-style-type:disc">And a[0] will go inside the first nested array</li></ul><ul id="d76df73f-2f2e-449e-9663-2e3244a377e5" class="bulleted-list"><li style="list-style-type:disc"><figure id="b51b2e97-595d-43f9-9d08-1677248449fc" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image25.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image25.png"/></a></figure></li></ul><h3 id="7d2ffe4e-fdef-4739-b784-681348e76d86" class="">Character Arrays and Strings</h3><ul id="552ad40b-03fa-4b67-b41e-76a9b992c701" class="bulleted-list"><li style="list-style-type:disc"><strong>char string_name[size]</strong></li></ul><ul id="eaa54afc-d8b9-4d5b-a88b-11fab9c82e94" class="bulleted-list"><li style="list-style-type:disc"><code>char city[9] = &quot;NEW YORK&quot;;</code></li></ul><ul id="e093250d-e5cb-47d9-8a9d-68ac1a1d3e46" class="bulleted-list"><li style="list-style-type:disc"><code>char city[9] = {‘N’, ‘E’, ‘W’, ‘ ‘, ‘Y’, ‘O’, ‘R’, ‘K’, ‘\0’};</code></li></ul><ul id="3e66b261-12c5-46bb-bce7-1a3e1ecf31cd" class="bulleted-list"><li style="list-style-type:disc">When we initialize a character array by listing elements we must supply explicitly the null terminator.</li></ul><ul id="0eae1b22-a3d6-4df3-90f9-aff78778a22d" class="bulleted-list"><li style="list-style-type:disc">scanf(&quot;%ws&quot;, name);</li></ul><ul id="aa76369c-16c3-4dd3-b013-5ba106f83188" class="bulleted-list"><li style="list-style-type:disc">Width w is less than the number of characters in the string, the excess characters will be truncated and left unread, only for scanf</li></ul><ul id="9604a772-50d2-481e-96fd-0d7abb2f59ff" class="bulleted-list"><li style="list-style-type:disc">When we are printing, if the field width is less than the length of the string, the entire string is printed</li></ul><ul id="172249ad-0c61-44b3-b91b-a418c8340a35" class="bulleted-list"><li style="list-style-type:disc">The integer number on the right of the decimal specified how many characters to print</li></ul><ul id="1bb839d5-d215-481a-ae95-5583bf9d031d" class="bulleted-list"><li style="list-style-type:disc">When the number of characters to be printed is 0, nothing is printed</li></ul><ul id="f43ac2d5-8e33-4ca0-81c0-ecc663b146b0" class="bulleted-list"><li style="list-style-type:disc">When we have a minus sign the string i left-justified</li></ul><ul id="ca5c06cb-1974-40f7-bb8d-7c33b916b06b" class="bulleted-list"><li style="list-style-type:disc">%ns prints first n characters</li></ul><ul id="d2ab617b-94a5-424c-9c3e-3d5ccd8ea251" class="bulleted-list"><li style="list-style-type:disc">Character Array ends with \0</li></ul><ul id="159874b4-fd6d-4e78-b005-65175734c129" class="bulleted-list"><li style="list-style-type:disc">—--------------------------------------------------------------------------</li></ul><ul id="a9dc549c-1a2f-4984-9479-f44a0db5ce26" class="bulleted-list"><li style="list-style-type:disc">char name[15] = &quot;BITS PILANI&quot;;</li></ul><ul id="d5d976f6-de8d-405b-a0d5-20db2eebd7c9" class="bulleted-list"><li style="list-style-type:disc">This gives B I T S _ P I L A N I \0 \0 \0 \0</li></ul><ul id="01884f6a-2a70-4c2d-94fb-cb776937898b" class="bulleted-list"><li style="list-style-type:disc">char name[10] =&quot;BITS PILANI&quot; <strong>NOT SUFFICIENT SPACE, WILL PRINT BITS PILAN</strong></li></ul><ul id="4ada6bc1-7247-4662-a638-abba2ed20423" class="bulleted-list"><li style="list-style-type:disc">char name[] <strong>SIZE IS MISSING</strong></li></ul><ul id="fd39cb35-40bf-4e56-951b-7cd30451cdcd" class="bulleted-list"><li style="list-style-type:disc">char name[12];</li></ul><p id="021ca777-92ca-46d3-beef-7d2c25331503" class=""><code>name = &quot;BITS PILANI&quot; ASSIGNMENT TO EXPRESSION WITH ARRAY TYPE ERROR</code></p><ul id="c3cbc37a-012e-4194-8886-a901c4761f9b" class="bulleted-list"><li style="list-style-type:disc">char str1[6] = &quot;Hello&quot;;</li></ul><pre id="a33071ff-576b-433f-a9b6-10f59d80c775" class="code"><code>char str2[6];
str2 = str1; NAME OF STRING IS POINTER THAT CAN NOT BE USED AS LVALUE</code></pre><ul id="591cb658-b2fc-4a30-934a-e5ca3c154c4c" class="bulleted-list"><li style="list-style-type:disc">scanf() terminates its input on the first white space - blank, tab, cr, ff, and new line</li></ul><ul id="f9b5a84a-a1f8-443d-828c-9ad7788feefa" class="bulleted-list"><li style="list-style-type:disc">We use gets but since it doesn’t check space, it’s unsafe</li></ul><ul id="68e311a0-a52b-4a84-ade0-8d9be9a4a682" class="bulleted-list"><li style="list-style-type:disc">getchar reads one character from stdin</li></ul><ul id="1c8f3a7c-8f47-4f8b-a8a4-357f1b5accc5" class="bulleted-list"><li style="list-style-type:disc">fgets is better</li></ul><ul id="a8bd85ba-8c0a-4d85-ab9b-f70ded3c6630" class="bulleted-list"><li style="list-style-type:disc">char str[10]; str = &quot;GOOD&quot; is <strong>NOT ALLOWED</strong></li></ul><ul id="1e68e285-9aaf-4949-9d17-633acf513792" class="bulleted-list"><li style="list-style-type:disc">%[^\n] can be used to take the whole line</li></ul><ul id="020d7334-a894-4e16-a918-77a183e55442" class="bulleted-list"><li style="list-style-type:disc">&amp;string[i] prints string after i characters</li></ul><ul id="8647729b-5c3c-4bef-8f50-a0fac9abe980" class="bulleted-list"><li style="list-style-type:disc">Number + string inside print also almost same</li></ul><figure id="cdcf97fa-9ef2-420e-9ce2-469a02294e29" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image4.png"><img style="width:558px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image4.png"/></a></figure><ul id="3d4f2806-ec1c-4868-baec-9b554792e715" class="bulleted-list"><li style="list-style-type:disc">This gives true/false because &quot;abc&quot; basically points to the first character and so this happens again with pointer</li></ul><h3 id="1818c8ce-7138-4cca-b695-cdb2d53ac7e5" class="">fgets and gets and fputs and puts</h3><ul id="03208413-3875-470a-b93a-0192a2fad8a9" class="bulleted-list"><li style="list-style-type:disc">fgets is better than gets. gets doesn’t check the limit of the variable</li></ul><ul id="9514cde6-95c7-4d63-8e9e-0707ed682074" class="bulleted-list"><li style="list-style-type:disc">fgets(variable_name, length, stdin);</li></ul><ul id="a425261f-ec94-4b96-8732-846a756c838b" class="bulleted-list"><li style="list-style-type:disc">fputs(string, stdout);</li></ul><ul id="4d3ce300-3788-48a3-9804-157774411dbf" class="bulleted-list"><li style="list-style-type:disc">It used to be char line[30]; gets(line); puts(line);</li></ul><ul id="12965013-2710-43a5-a949-f70bb5ea504e" class="bulleted-list"><li style="list-style-type:disc">Only for characters, for integers or anything else use <code>fprintf(FILE POINTER, CONTROL STRING,ARGUMENTS);</code></li></ul><h3 id="c23305ad-84a8-45b4-b262-c28963652c52" class="">Arithmetic on Characters</h3><ul id="4902a3d6-5ab9-4b68-8611-ede54b298308" class="bulleted-list"><li style="list-style-type:disc">If we have x = ‘a’ and we print it using %d it prints it’s ascii number</li></ul><ul id="025048aa-e76c-4d5d-b16c-a8a3f761f89a" class="bulleted-list"><li style="list-style-type:disc">If we have x=’a’-1 the %d will become ascii(a)-1</li></ul><ul id="083dd2da-50d0-4695-a0fd-90783b0f93b7" class="bulleted-list"><li style="list-style-type:disc">Capital Letters start from 65</li></ul><ul id="4af74703-ee74-4376-b404-2a12ca04a4d5" class="bulleted-list"><li style="list-style-type:disc">x = character - ‘0’;</li></ul><ul id="50fb9e52-c8a3-4b3b-9579-95a627ae574c" class="bulleted-list"><li style="list-style-type:disc">x = ascii of ‘7’ - ascii of ‘0’ = 55-48 = 7</li></ul><ul id="5d73b4a2-c999-47e3-a3cb-30255b747b18" class="bulleted-list"><li style="list-style-type:disc">String of digits into their integer value: Use x = atoi(string);</li></ul><h3 id="1f2bd59e-b574-4b11-a41c-523e6235766b" class="">String Manipulation Functions</h3><ul id="4540552b-f498-4f2e-97d9-0bf7c03245ec" class="bulleted-list"><li style="list-style-type:disc"><code>char *strcpy(char *s1, const char *s2);</code><ul id="4060aa42-f00a-42c8-87c1-d117df09d4fd" class="bulleted-list"><li style="list-style-type:circle">strcpy has no way to check that s2 fits in s1, if it doesn’t fit, gives undefined behavior</li></ul></li></ul><ul id="4bdf1a65-cbd9-4168-ab2b-07a1a6b4bbcd" class="bulleted-list"><li style="list-style-type:disc"><code>char *strncpy(char *s1, const char *s2, size_t n);</code></li></ul><ul id="a54a890c-f984-4ea7-acf5-8f34b0a4b79f" class="bulleted-list"><li style="list-style-type:disc">char *strcmp and *strncmp compare two strings and gives 0 if they are equal and &lt;0 if str1&lt;str2 and &gt;0 if str1&gt;str2</li></ul><ul id="c25ed79a-39c9-44bd-a79a-ec1bb3a454fb" class="bulleted-list"><li style="list-style-type:disc">strcat will concatenate strings using strcat(s1, &quot;GOOD&quot;);</li></ul><ul id="08c3fc0d-2b64-42de-b274-84f40896b51a" class="bulleted-list"><li style="list-style-type:disc">strncmp will only check if characters in size are given</li></ul><ul id="9ebc66f0-a0a3-4c4e-8e5e-3a2a9a4632d6" class="bulleted-list"><li style="list-style-type:disc">ABC123 and 123ABC with size -1 it will return 0 as it’ll count the last character which is \0</li></ul><ul id="087d200f-d138-45f4-9bca-da763ca79f4e" class="bulleted-list"><li style="list-style-type:disc">ABC123 and ABC456 with size 3 will return 0</li></ul><ul id="8c035fa6-6776-40ee-9c71-0a078ae578c1" class="bulleted-list"><li style="list-style-type:disc">strlen gives the length of the string before \0</li></ul><ul id="65c5c369-c127-432c-896d-e99fa8e62315" class="bulleted-list"><li style="list-style-type:disc">strstr(s1, &quot;CAT&quot;); if s1 = &quot;CONCATENATION&quot;</li></ul><ul id="80c187db-283d-4a47-86a5-ac4d2be800ec" class="bulleted-list"><li style="list-style-type:disc">while(*s1++ = *s2++); can be used to copy the whole string in one line of code</li></ul><h3 id="2cb06676-d602-4bf3-9d5e-44272cabd44c" class="">Structures</h3><ul id="fab2e203-f943-4320-88f9-ba25a1dae9eb" class="bulleted-list"><li style="list-style-type:disc">Structures are used when we want to combine multiple data types in a single data type, say we want something to have both name and age</li></ul><ul id="3ccb887d-9a5b-4ba5-8cf0-4b6f0909646b" class="bulleted-list"><li style="list-style-type:disc">We can only use dot or arrow to access elements of a struct</li></ul><ul id="2b02f729-61e5-4834-bbd3-a3d941b5a4c8" class="bulleted-list"><li style="list-style-type:disc">You <strong>can only use ./-&gt;/=/&amp; on structs</strong></li></ul><ul id="99bb35e2-4d28-4327-9ea9-b9f6afe43e5b" class="bulleted-list"><li style="list-style-type:disc"><strong>Members do not occupy any memory until they are associated with structure variables</strong></li></ul><ul id="058a0c84-19e8-4977-8b44-901ddca856dc" class="bulleted-list"><li style="list-style-type:disc">We cannot initialize variables inside a struct</li></ul><ul id="e53a459b-5b49-4424-b6c7-dc26a9fb7487" class="bulleted-list"><li style="list-style-type:disc">We can initialize one struct type variable in the starting itself but then it has to be in the same order</li></ul><ul id="f6eeec81-6b02-4f6f-b87f-7f06140810c6" class="bulleted-list"><li style="list-style-type:disc">C cannot have static members in structs</li></ul><ul id="6b119245-88fd-4920-a317-4264f242b00f" class="bulleted-list"><li style="list-style-type:disc">A structure cannot contain a member of its own type because if this is allowed then it becomes impossible for the compiler to know the size of such a struct. Although a pointer of the same type can be a member because pointers of all types are of the same size and the compiler can calculate the size of the struct</li></ul><ul id="396383fb-1978-49d1-8643-63d2fa40328f" class="bulleted-list"><li style="list-style-type:disc">Structs can&#x27;t be compared using ==</li></ul><ul id="d82efb2c-e5f4-4f13-bb8f-25a98b064c8b" class="bulleted-list"><li style="list-style-type:disc">We can use typedef to ensure that we can use this struct everywhere else using a simple name</li></ul><pre id="3deac45e-b96f-4745-8448-bf22444f2267" class="code"><code>typedef struct{
	type member1;
} type_name;</code></pre><ul id="5261619a-bb2e-4a6e-ac93-18579a0eb307" class="bulleted-list"><li style="list-style-type:disc">We access structure data by using type_name.member1</li></ul><ul id="8685c0d9-48d5-4329-8cef-29921de2e6b9" class="bulleted-list"><li style="list-style-type:disc">Use &amp;variable to store data into a struct element</li></ul><ul id="bce917dd-aceb-4364-9708-b94b5f4c8fea" class="bulleted-list"><li style="list-style-type:disc">When initializing struct using = {}, it takes elements linearly</li></ul><ul id="15581b35-e9b4-4393-af1e-a2d2b58c9e15" class="bulleted-list"><li style="list-style-type:disc">C does not permit any logical operations on structure variables</li></ul><ul id="bfb1e697-5686-4d1e-92c3-c6489499fb9c" class="bulleted-list"><li style="list-style-type:disc"><figure id="ce1954aa-3c3d-4cd8-a5e3-1ea180376a42" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image2.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image2.png"/></a></figure></li></ul><ul id="2f531a73-0940-4cc4-a41a-081d8f7d1a78" class="bulleted-list"><li style="list-style-type:disc">Nested Structures are nice, but the person reading this is probably high on something to study nested structures at this point of life, but then we had this for lab so yeah be prepared</li></ul><ul id="65924e6b-3440-493c-997c-8936353eeecc" class="bulleted-list"><li style="list-style-type:disc">If we have</li></ul><pre id="b221c2a4-6414-496e-b79c-3ead306020cd" class="code"><code>struct A {
	int x;
	double z;
	short int y;
};</code></pre><p id="965324b5-d109-405e-81df-6cada5793887" class=""><code>printf(&quot;%d&quot;, sizeof(struct A)); //Size will give 24</code></p><ul id="b21548f0-e99d-4f4f-9432-542054ee2fb6" class="bulleted-list"><li style="list-style-type:disc">The use of pointers in structure members saves a lot of memory</li></ul><ul id="c8e7658c-83dd-4b8e-b35e-07d032bac2c1" class="bulleted-list"><li style="list-style-type:disc">Structure padding is used to find space occupied by structures, which says that it follows variable declaration order and allocates memory such that full variable can be accessed but using address by word where the word is 4 or 8 bytes depending on the system</li></ul><ul id="680bac05-2f4d-4927-9151-f50104dc5077" class="bulleted-list"><li style="list-style-type:disc"><strong>Size of struct depends on structure padding</strong></li></ul><ul id="cf7108f9-f22d-437e-a0e1-c15867b1b21d" class="bulleted-list"><li style="list-style-type:disc"><a href="https://iq.opengenus.org/size-of-struct-in-c/#:~:text=In%2032%20bit%20processor%2C%20it,save%20number%20of%20CPU%20cycles.">Size of struct in C/ C++ (opengenus.org)</a></li></ul><h3 id="afed2e9a-a37b-40f5-9b2a-606d60d85300" class="">Unions</h3><ol type="1" id="f515ea56-31ce-4533-8329-53cb0ac1659a" class="numbered-list" start="1"><li>Unions are similar to structures but the only difference is in the storage part, where structure allots memory for all the elements while union allots memory for the largest element but stores all of them depending on which one of them is being used.</li></ol><ol type="1" id="d911728e-4ebf-443b-874b-dcb4a6da8193" class="numbered-list" start="2"><li><strong>Size of union is size of max sized element in the union</strong></li></ol><ol type="1" id="a817b153-221c-4306-9602-9e661fe3eef4" class="numbered-list" start="3"><li>So it’s like if we are using <strong>union.a</strong> you can’t use union.b</li></ol><ol type="1" id="d9d7ffb2-0f52-49c6-a5a4-148d6246eee8" class="numbered-list" start="4"><li>Can only be initialized with elements of the first type in the union</li></ol><ol type="1" id="b6d1206d-6186-4bb4-aa8e-bd30ead3bea2" class="numbered-list" start="5"><li>So if we put union element = 0, and try to access the next one, it’ll also be 0</li></ol><h3 id="2f2fa612-5eb1-4c02-84ab-229fe4b0db68" class="">Pointers</h3><ol type="1" id="80e10aa8-c423-47ab-ad82-373f5fcbee81" class="numbered-list" start="1"><li>A pointer is a constant or a variable that contains an address that can be used to access the data stored at that address</li></ol><ol type="1" id="885c2ba4-e113-412c-95c2-5d4903e3084f" class="numbered-list" start="2"><li>Derived datatype</li></ol><ol type="1" id="3418c0f5-7067-496d-bbf5-c0707be899b0" class="numbered-list" start="3"><li>&amp; is the address-of operator</li></ol><ol type="1" id="8211829c-0685-4305-8a52-a94e9f0775d6" class="numbered-list" start="4"><li>is the value at operator</li></ol><ol type="1" id="1aba6c0a-7454-4623-9986-539cd801b407" class="numbered-list" start="5"><li>&amp; can only be used for a simple variable or an array element</li></ol><ol type="1" id="cff731be-e6e3-4ab7-998e-f778952df7e8" class="numbered-list" start="6"><li>&amp;125 is wrong</li></ol><ol type="1" id="56e07612-9276-4ed5-a87d-17899eff1d9c" class="numbered-list" start="7"><li>int x[10]; &amp;x is also illegal(though works)</li></ol><ol type="1" id="f370c7f8-24e9-4f18-98da-8ca67668bc38" class="numbered-list" start="8"><li>If x is an array, &amp;x[0] and &amp;x[i+3] work</li></ol><ol type="1" id="40cb6e2c-8f6e-4f6f-923f-df5bf37d3179" class="numbered-list" start="9"><li>int q;</li></ol><p id="679f2859-efdb-4428-918b-1841e74cf652" class=""><code>int *p = &amp;q; OR int *p; p=&amp;q;</code></p><ol type="1" id="23108edc-8d02-4286-a6b0-45c55e73c626" class="numbered-list" start="1"><li>int *p = NULL or 0 is valid</li></ol><pre id="9dfd9bb1-56b6-4cc5-ad49-3deb7741bb99" class="code"><code>#include &lt;stdio.h&gt;

void main(){
	int i = 10; //Value of 10 in i
	int *ptr = &amp;i; //ptr stores address of i and *ptr shows 10
	int **pptr = &amp;ptr; //pptr stores address of ptr and **pptr shows 10
	printf(&quot;%u&quot;, **pptr); //Will print 10
}</code></pre><figure id="cf6da212-3d69-4b63-a5fa-86e1047dc8ac" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image33.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image33.png"/></a></figure><ol type="1" id="0e66a4d4-b482-4cca-9070-cbb856cfab7c" class="numbered-list" start="1"><li>Pointers cannot be multiplied or divided</li></ol><ol type="1" id="85f4f2e7-40c3-40b5-9b2f-a4930c57ecb7" class="numbered-list" start="2"><li>The addition of pointers is also illegal</li></ol><ol type="1" id="1f2098c8-4daa-4e4c-82cb-395628d8a8c4" class="numbered-list" start="3"><li>ptr++ will make the pointer go to the <strong>NEXT VALUE OF SAME TYPE</strong></li></ol><ol type="1" id="ecac0973-169a-43b8-b9f7-8697f54d3ad0" class="numbered-list" start="4"><li>The size of the pointer depends on the compiler, if we use 64bit we get 8bytes, as in if we have an int *p; sizeof(p)=8 but sizeof(*p)=4</li></ol><figure id="447d4668-92ae-465a-95e4-ac1d9a5a5341" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image1.png"><img style="width:439px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image1.png"/></a></figure><ol type="1" id="93615ce6-f4d3-4de1-9611-ea2f5df19be1" class="numbered-list" start="1"><li>const int *ptr is a pointer pointing to a constant int, so that means you can’t change the value of that int but can change the whole pointer itself as in where it points</li></ol><ol type="1" id="0ab3f51f-3402-42b7-bca8-3dd26952cf98" class="numbered-list" start="2"><li>int *const ptr is a constant pointer pointing to an int, here we can change the value but we can’t change where a pointer is pointing</li></ol><figure id="a9409e48-b3cf-4bcb-91e8-1ea7fb533aec" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image12.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image12.png"/></a></figure><ol type="1" id="a6eb29e3-4858-4450-a301-522856f35920" class="numbered-list" start="1"><li>Function pointers:<ol type="a" id="18760712-31de-4c76-b9ce-7b18cd17df06" class="numbered-list" start="1"><li>function return type (*pointername)(function argument list)</li></ol><ol type="a" id="a9dc14ee-4d90-4f31-82f6-5700798d171b" class="numbered-list" start="2"><li>int(*f2p)(int, int);</li></ol><ol type="a" id="f52f2eb7-d0ba-413d-894a-61d68c06a97a" class="numbered-list" start="3"><li>f2p = sum; //where int sum(int num1, int num2) is a different function</li></ol></li></ol><figure id="35daebb0-eef8-4feb-a75f-9e0d1dd30fd3" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image17.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image17.png"/></a></figure><h3 id="d49fe040-5758-4853-a860-d1086e619f64" class="">2D pointer arithmetic</h3><figure id="97b46506-b89d-4d98-b565-56f7a28b0e13" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image21.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image21.png"/></a></figure><ol type="1" id="e329eed9-c163-4fa7-843e-cf9e4460e9be" class="numbered-list" start="1"><li><figure id="91861f67-17d0-4b44-85ee-f3170f172c32" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image28.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image28.png"/></a></figure></li></ol><ol type="1" id="ff9edf5f-39b1-484b-b57b-01996604fcfc" class="numbered-list" start="2"><li><figure id="0ddb510d-cbe0-4c52-baf2-9275fdafadbc" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image22.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image22.png"/></a></figure></li></ol><ol type="1" id="481da0c0-acff-4e3e-80d7-15814db32113" class="numbered-list" start="3"><li>Basically logic here is when you are typecasting and subtracting the size changes according to the type you are casting it to.</li></ol><ol type="1" id="f285e256-dd48-41c0-aca4-3c7d3e4bc58b" class="numbered-list" start="4"><li>A void pointer cannot be dereferenced</li></ol><ol type="1" id="866fa42d-01ac-4c71-a596-65d2a000e97d" class="numbered-list" start="5"><li>ptr–&gt;p Fetches whatever p points to.</li></ol><ol type="1" id="adeea4d2-83c5-4661-acf5-fe6acc2c2e40" class="numbered-list" start="6"><li>ptr–&gt;p++ Increments p after accessing whatever it points to</li></ol><ol type="1" id="75adfe96-0d03-47a6-b7fd-2852a6860c22" class="numbered-list" start="7"><li>(*ptr–&gt;p)++ Increments whatever p points to.</li></ol><ol type="1" id="9eb647da-b4f9-4c8a-9d6c-6ccaef1f19b7" class="numbered-list" start="8"><li>ptr++–&gt;p Increments ptr after accessing whatever it points to</li></ol><ol type="1" id="6fe05c59-ee0c-48b5-bd26-523ff0178581" class="numbered-list" start="9"><li><figure id="f6c08ae7-fc17-4196-814c-02e9d209c28e" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image6.png"><img style="width:373px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image6.png"/></a></figure></li></ol><ol type="1" id="cd57788c-ef80-4811-9fe3-c3fd1b06caef" class="numbered-list" start="10"><li>Dangling Pointers<ol type="a" id="51659558-f402-4417-a3f8-22ce5431a684" class="numbered-list" start="1"><li>A pointer that is freed up but is used in the code later</li></ol><ol type="a" id="f6ffdeca-d4a9-4c31-a089-bac1db15cd5a" class="numbered-list" start="2"><li>It exists but it is not pointing to anything</li></ol><ol type="a" id="8a763799-3416-4303-a203-017cf835d52b" class="numbered-list" start="3"><li>Here the output will be 9 9 but undefined behavior</li></ol><ol type="a" id="8d9d413b-1c08-4942-b984-4dc749bf24b0" class="numbered-list" start="4"><li>Dangling pointers still can print addresses and their value</li></ol></li></ol><pre id="65d26459-1b89-4146-8be1-0b5eb55e7e46" class="code"><code>int main(){
	int *ptr;
	 {
		int a = 9;
		ptr = &amp;a;
		printf(&quot;%d &quot;, *ptr);
	}
	printf(&quot;%d&quot;, *ptr);
}</code></pre><p id="5cddfbfa-5024-4433-b8ad-091038772b8f" class="">=====================================================</p><ol type="1" id="01a998f6-51a9-498b-b47e-b8d73576c922" class="numbered-list" start="1"><li>Here it won’t print anything</li></ol><pre id="a0444da4-6bb5-4c00-9039-679291b7f0c8" class="code"><code>#include &lt;stdio.h&gt;

	int *f(){
		int a = 0;
		return &amp;a;
	}

int main(){
	int *ptr = f();
	printf(&quot;-%d-&quot;, *ptr);
	//Here ptr becomes a dangling pointer
}</code></pre><figure id="c63d9ad8-e228-47b7-b97e-79a7a777c2ea" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image37.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image37.png"/></a></figure><figure id="4609f90b-a88d-4cc5-b684-0d74074dd56c" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image39.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image39.png"/></a></figure><h3 id="ff065986-375c-4e43-aadb-4822b59bd6af" class="">Wild Pointer</h3><ol type="1" id="a6a61d22-303a-4801-b9d9-a5c683b8606e" class="numbered-list" start="1"><li>If it’s uninitialized it’s called wild pointer</li></ol><h3 id="5290a608-d21a-4391-be3e-ab24e622c349" class="">Pointer Precedence</h3><ol type="1" id="0df01684-b7b9-424d-87bf-157a754580bb" class="numbered-list" start="1"><li>Precedence of <strong>prefix ++ and *</strong> is the same. Associativity of both is right to left</li></ol><ol type="1" id="a02af04a-a079-43b8-8513-d58d3d0c38d1" class="numbered-list" start="2"><li>Precedence of <strong>postfix ++ is higher</strong> than both * and prefix ++. Associativity of postfix ++ is left to right.</li></ol><ol type="1" id="2492c4cc-3338-45df-98e0-ec85343e3849" class="numbered-list" start="3"><li>The expression <strong>++*p</strong> has two operators of same precedence, so compiler looks for associativity. Associativity of operators is right to left. Therefore the expression is treated as <em><strong>++(*p)</strong></em>. Therefore the output of first program is &quot;<em>arr[0] = 11, arr[1] = 20, *p = 11</em>&quot;.</li></ol><ol type="1" id="704c8f79-02e3-4694-b429-590cb4d2ad08" class="numbered-list" start="4"><li>The expression <strong>p++</strong> is treated as <em><strong>(p++)</strong></em> as the precedence of postfix ++ is higher than *. Therefore the output of second program is &quot;<em>arr[0] = 10, arr[1] = 20, *p = 20</em> &quot;.</li></ol><ol type="1" id="de5afb0a-caf7-42c5-9994-da988d7d66f6" class="numbered-list" start="5"><li>The expression <strong>++p</strong> has two operators of same precedence, so the compiler looks for associativity. Associativity of operators is right to left. Therefore the expression is treated as <em><strong>(++p)</strong></em>. Therefore the output of third program is &quot;<em>arr[0] = 10, arr[1] = 20, *p = 20</em>&quot;.</li></ol><ol type="1" id="1924b529-ecfa-4aae-892f-75eef78e801b" class="numbered-list" start="6"><li>Please write comments if you find anything incorrect, or if you want to share more information about the topic discussed above.</li></ol><h2 id="2e16e8ba-10d3-453c-aa8a-7b7e4a9dc4a6" class="">File Management</h2><ol type="1" id="2ebea14a-7a1b-410a-bd29-0c847efd56f0" class="numbered-list" start="1"><li>We use file pointers for opening and closing files</li></ol><pre id="59d45c58-7096-47b4-bff2-d342e5ce561f" class="code"><code>FILE *fptr;
fptr = fopen(&quot;filename&quot;, &quot;mode&quot;); //modes where r-read, w-write, a-append</code></pre><ol type="1" id="bd30a325-34da-45bd-93a5-34d42ad7c0af" class="numbered-list" start="1"><li>Reading gives error if file doesn’t exist</li></ol><ol type="1" id="c510468a-341c-40d1-acf6-eb761c3f0f91" class="numbered-list" start="2"><li>if(feof(fptr)) is used to check for eof errors</li></ol><ol type="1" id="e1d145ff-8d56-4ffc-9686-9ad8d592af5f" class="numbered-list" start="3"><li>if(ferror(fp) != 0) is used to check for any other errors</li></ol><ol type="1" id="a3cb5e54-4252-42d0-a679-c4ffef50e370" class="numbered-list" start="4"><li>if(fp == NULL), file couldn’t be opened</li></ol><ol type="1" id="e599eacf-17ea-4993-808a-a52e56914a57" class="numbered-list" start="5"><li>A file is nothing but a source of storing related data in the form of a sequence of bytes on disk or tape</li></ol><ol type="1" id="11e26537-6e4e-43f0-84d9-b7d486c7ab8f" class="numbered-list" start="6"><li><figure id="6df0c614-95d1-4f33-9cc3-dd14ba68bdfc" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image38.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image38.png"/></a></figure></li></ol><ol type="1" id="5fc63a61-9abb-4781-bf04-cc5a30fb2bf2" class="numbered-list" start="7"><li>Close the file after opening it</li></ol><ol type="1" id="2d436d2e-c3bc-4c02-adb1-c3e4c318240b" class="numbered-list" start="8"><li>Getc and putc read characters from a file</li></ol><ol type="1" id="fa26296e-d3c1-4e9b-9976-0654c0fe09cb" class="numbered-list" start="9"><li>Getw and putw read-only integers from a file</li></ol><ol type="1" id="63bb26fe-1887-43ce-ad42-5ed32709d8ef" class="numbered-list" start="10"><li>fprintf and fscanf are the same as printf and scanf but for files, where the syntax is as follows <code><strong>fprintf(fp, &quot;control string&quot;, input);</strong></code></li></ol><ol type="1" id="bb13329c-499e-4940-ad68-5b6aa9a9ce43" class="numbered-list" start="11"><li>If we put stdin/stdout instead of fp, that’s basically taking input and output from the user</li></ol><ol type="1" id="b0358170-1b1e-45aa-801a-f254335c6204" class="numbered-list" start="12"><li>Random Access to files:<ol type="a" id="0dc6905f-b8dc-4e0d-b871-fcf0828baa77" class="numbered-list" start="1"><li>n = ftell(fp) returns a long value with the position of the current place in the file</li></ol><ol type="a" id="a18f60a6-68c7-4803-a5af-139b4bb5ff20" class="numbered-list" start="2"><li>rewind(fp) takes a pointer and resets its location to the starting position of the file</li></ol><ol type="a" id="5d4bcfa8-1ac3-4f63-839c-dac3d43734b4" class="numbered-list" start="3"><li><code><strong>fseek(pointer, howmuchdistancetomove, fromwheretomove);</strong></code></li></ol><ol type="a" id="97ccc37d-b012-452d-896a-711fe27e53c6" class="numbered-list" start="4"><li>The last argument can take 0: Beginning of file, 1: current position, 2: end of file</li></ol><ol type="a" id="e7f41a26-cd6b-4f2f-8f64-d8697af39545" class="numbered-list" start="5"><li><figure id="b593b9e5-f87b-4520-aaef-5a0d3b99554f" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image18.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image18.png"/></a></figure></li></ol><ol type="a" id="4abb37a1-f198-46f6-a27c-8eb6f1ef66a4" class="numbered-list" start="6"><li><figure id="aa77d85d-a890-4871-98df-6cdfabbaddbd" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image9.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image9.png"/></a></figure></li></ol><ol type="a" id="50d022e1-a296-417e-b16e-e97135412700" class="numbered-list" start="7"><li>Here L represents long</li></ol><ol type="a" id="b2cf6771-a980-49e8-ae9a-fc00a1591d44" class="numbered-list" start="8"><li>fwrite(addressinbits, sizeof(each), noofeach, filepointer) is used for binary reading and writing<figure id="0598444f-fd85-4ab7-95e7-5b8c72f0fa4b" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image15.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image15.png"/></a></figure><figure id="3160bc06-bf2f-4501-94f2-4bc73435ac9b" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image11.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image11.png"/></a></figure></li></ol></li></ol><h2 id="7fd03fae-b2b0-44fd-8691-282284c5df9b" class="">Dynamic Memory Allocation</h2><ol type="1" id="8d996a6a-4728-44ef-9005-d0c2f130d518" class="numbered-list" start="1"><li>Dynamic Memory allocation uses heap while static uses stack which is not permanent</li></ol><ol type="1" id="0f48d196-786e-4cff-9069-11ffe7d02b70" class="numbered-list" start="2"><li>Malloc returns void*, will return null if it couldn’t allocate enough space</li></ol><ol type="1" id="3b141b8a-50ba-41cc-853b-fbe9dd9e3be2" class="numbered-list" start="3"><li>Malloc(Memory allocation) allocates the request size of bytes and returns a pointer to the first byte of the allocated space</li></ol><ol type="1" id="77032755-95b7-4f5b-9fd1-bb42ddc29688" class="numbered-list" start="4"><li>Calloc(Continuous Allocation) allocates space for an array of elements, initializes them to 0, then returns the pointer, this needs the number of elements in the array also</li></ol><ol type="1" id="daff1e15-ec87-40c6-b431-a67fecb5e6b8" class="numbered-list" start="5"><li>Free frees previously allocated space</li></ol><ol type="1" id="adcdd69a-dce2-43fe-97fb-1a98f9ff575e" class="numbered-list" start="6"><li>If we free already free space, we might get undefined behavior or segmentation error</li></ol><ol type="1" id="2575b2ba-a29d-441d-94dd-8d454eee9568" class="numbered-list" start="7"><li>Realloc modifies previously allocated space, when we are decreasing the size, we remove the last few blocks/elements</li></ol><ol type="1" id="600c6f4e-a626-4e54-b868-d0fcadf1f249" class="numbered-list" start="8"><li>We use malloc-&gt;</li></ol><pre id="c6f65433-9afc-4b7e-90d7-a70326d06bb5" class="code"><code>ptr = (cast-type *) malloc(byte-size);</code></pre><ol type="1" id="9c336755-0393-453d-9d10-010aa774b351" class="numbered-list" start="1"><li>Calloc is used to allocate data in runtime and puts 0 as default, this allocates continuously and this allocates multiple blocks when in comparison with malloc</li></ol><pre id="5e8820ca-ec6d-4d40-88fb-b5b559dc2e02" class="code"><code>ptr = (cast-type *) calloc (n, elem-size);</code></pre><ol type="1" id="845b13ea-8698-4417-9391-9e1c3ab61706" class="numbered-list" start="1"><li>For realloc,</li></ol><pre id="41bc55be-6fe5-4aeb-9548-fd2b401c0487" class="code"><code>ptr = realloc(ptr, newsize);</code></pre><ol type="1" id="3dbc7230-55a6-40f2-9c2f-b6c41d5e069a" class="numbered-list" start="1"><li>Realloc for calloc will add new blocks but doesn’t change the size of each block</li></ol><figure id="248a9da1-27aa-4e25-91ce-ee07c398a531" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image29.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image29.png"/></a></figure><ol type="1" id="a6590491-cc6b-41ea-a8d4-1c134df70ff1" class="numbered-list" start="1"><li>free() can be called for a NULL pointer, so no problem with a free function call. The problem is a <strong>memory leak</strong>, p is allocated some memory that is not freed, but the pointer is assigned as NULL. The correct sequence should be the following: <strong>free(p); p=NULL;</strong></li></ol><ol type="1" id="6ea642f7-5966-4182-8e01-7c15165c8c5b" class="numbered-list" start="2"><li><figure id="d6ffa4cc-c625-42bb-9562-18f1a0557abb" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image26.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image26.png"/></a></figure></li></ol><ol type="1" id="87ca9605-2e9a-4c7d-a814-a0555808f62e" class="numbered-list" start="3"><li>All these are in &lt;stdlib.h&gt;</li></ol><figure id="858a241b-7b97-4bd7-85c3-ed4ce513c1f8" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image8.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image8.png"/></a></figure><ol type="1" id="1b3d9439-7465-4404-bd14-ed49a697bed7" class="numbered-list" start="1"><li>The above code is for the concat function in C</li></ol><ol type="1" id="c054c39e-a5c7-47cc-8f4b-9cb2734325f5" class="numbered-list" start="2"><li>Improper code in DMA leads to memory leak</li></ol><h2 id="215a9230-0f9b-450d-912d-565c4818c9d1" class="">Linked Lists</h2><ol type="1" id="b4e0d36b-9b28-4680-8798-690f753c6fad" class="numbered-list" start="1"><li>Data elements are arranged sequentially and all the elements can be traversed in a single run. Ex: Array, Stack, Queue, Linked list.</li></ol><ol type="1" id="fc8a1c5a-9c75-44e1-93d0-0cff56544ee5" class="numbered-list" start="2"><li>Data elements are not arranged sequentially and not all the elements can be traversed in a single run. Ex: Trees and Graphs.</li></ol><ol type="1" id="89120f1e-27f2-46ef-baf2-e7568bc1449a" class="numbered-list" start="3"><li>Code</li></ol><pre id="dd79cab3-5721-4ab4-8ba6-56e9ec36cd53" class="code"><code>#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;

typedef struct node
{

    int value;

    struct node *next;

} node;

void addAtEnd(node *head);

void addAtBeginning(node **head);

void addAtMiddle(node *head, int t);

void deleteEnd(node *head);

void deleteHead(node **head);

void printNodes(node *head);

int main()
{

    node *head = (node *)malloc(sizeof(node));

    int initial;

    printf(&quot;Enter initial value for LinkedList: &quot;);

    scanf(&quot;%d&quot;, &amp;initial);

    head-&gt;value = initial;

    head-&gt;next = NULL;

    int n;

    printf(&quot;Enter the number of elements you want to add to the list: &quot;);

    scanf(&quot;%d&quot;, &amp;n);

    while (n--)
    {
        addAtEnd(head);
    }

    printNodes(head);

    printf(&quot;Enter the number of elements you want to delete from the list from behind: &quot;);

    scanf(&quot;%d&quot;, &amp;n);

    while (n--)
    {
        deleteEnd(head);
    }

    printNodes(head);

    printf(&quot;Enter the number of elements you want to delete from the list from front: &quot;);

    scanf(&quot;%d&quot;, &amp;n);

    while (n--)
    {
        deleteHead(&amp;head);
    }

    printNodes(head);

    printf(&quot;Enter the number of elements you want to add to the beginning of the list: &quot;);

    scanf(&quot;%d&quot;, &amp;n);

    while (n--)
    {
        addAtBeginning(&amp;head);
    }

    printNodes(head);

    printf(&quot;Enter the number of elements you want to add to the middle of the list: &quot;);

    scanf(&quot;%d&quot;, &amp;n);

    while (n--)
    {

        int m;

        printf(&quot;Enter index: &quot;);

        scanf(&quot;%d&quot;, &amp;m);

        addAtMiddle(head, m);
    }

    printNodes(head);
}

void addAtEnd(node *head)
{

    int a;

    printf(&quot;Enter the number: &quot;);

    scanf(&quot;%d&quot;, &amp;a);

    node *temp = head;

    while (temp-&gt;next != NULL)
    {

        temp = temp-&gt;next;
    }

    node *newNode = (node *)malloc(sizeof(node));

    newNode-&gt;value = a;

    newNode-&gt;next = NULL;

    temp-&gt;next = newNode;

    printf(&quot;Added number successfully\n&quot;);
}

void addAtBeginning(node **head)
{

    int a;

    printf(&quot;Enter the number you want to insert at the beginning: &quot;);

    scanf(&quot;%d&quot;, &amp;a);

    node *newNode = (node *)malloc(sizeof(node));

    newNode-&gt;value = a;

    newNode-&gt;next = *head;

    -head = newNode;

    printf(&quot;Added number to the beginning successfully\n&quot;);
}

void printNodes(node *head)
{

    node *temp = head;

    printf(&quot;Printing Values\n&quot;);

    while (temp-&gt;next != NULL)
    {

        printf(&quot;%d -&gt;&quot;, temp-&gt;value);

        temp = temp-&gt;next;
    }

    printf(&quot;%d -&quot;, temp-&gt;value);

    printf(&quot;END\n&quot;);
}

void addAtMiddle(node *head, int t)
{

    int a, b;

    printf(&quot;Enter the number you want to insert: &quot;);

    scanf(&quot;%d&quot;, &amp;a);

    node *temp = head;

    printf(&quot;%d&quot;, head-&gt;value);

    for (int s = 1; s &lt; t; s++)
    {

        temp = temp-&gt;next;
    }

    node *newNode = (node *)malloc(sizeof(node));

    newNode-&gt;value = a;

    newNode-&gt;next = temp-&gt;next;

    temp-&gt;next = newNode;
}

void deleteEnd(node *head)
{

    node *temp = head;

    while (temp-&gt;next-&gt;next != NULL)
    {

        temp = temp-&gt;next;
    }

    // Temp is last second node

    // Here we try to remove the last node

    node *p = temp-&gt;next;

    temp-&gt;next = NULL;

    free(p);
}

void deleteHead(node **head)
{

    node *temp = *head;

    -head = (*head)-&gt;next;

    free(temp);
}
&gt;</code></pre><h2 id="6c1719db-dbf4-4e19-9e5a-c639468f2f8c" class="">Storage Classes</h2><ol type="1" id="8ea32e77-2436-470f-93cc-3ba70b9ac9e5" class="numbered-list" start="1"><li><strong>Scope</strong>: Where will the variable be available</li></ol><ol type="1" id="390e052e-f01e-4c4d-bc33-bd950f7e5d48" class="numbered-list" start="2"><li><strong>Default Value</strong>: Initial Value</li></ol><ol type="1" id="8e3f1d6d-8781-40e8-b788-f5dea1eb5c45" class="numbered-list" start="3"><li><strong>Lifetime</strong>: Till when will they survive</li></ol><ol type="1" id="7b6a51eb-e3ca-4a20-b8a5-01b9e8a21890" class="numbered-list" start="4"><li><strong>Automatic</strong> Variable:<ol type="a" id="979706ec-2ae0-45ee-82aa-56d13546dfa0" class="numbered-list" start="1"><li>Variable defined without class is automatic so, int and auto int are the same</li></ol><ol type="a" id="50593919-46e3-44ec-a29d-9b56c51d1125" class="numbered-list" start="2"><li>Local to the function body they are defined in</li></ol><ol type="a" id="b7349175-9825-43c9-b57a-8e1c1819b06a" class="numbered-list" start="3"><li>Defaults to a garbage value</li></ol><ol type="a" id="906da556-0ffd-49b3-896e-b7edd487fcba" class="numbered-list" start="4"><li>Lifetime is till the end of the function they are defined in</li></ol><ol type="a" id="2dbcbc7a-b5df-49d3-a66e-c345b864baa7" class="numbered-list" start="5"><li>Can’t use auto for global variables, will get an error</li></ol></li></ol><ol type="1" id="3b4fd046-f9c2-426e-b811-aed4de278a39" class="numbered-list" start="5"><li><strong>External</strong> Variable:<ol type="a" id="a454fc2e-1430-4751-a704-210dc336244f" class="numbered-list" start="1"><li>Defaults to 0</li></ol><ol type="a" id="81a6cbf0-3c52-4e4d-893a-d7b5005e64bd" class="numbered-list" start="2"><li>The scope is global to the program they are in</li></ol><ol type="a" id="3cb091f0-7e1a-4963-b304-692b329acf8b" class="numbered-list" start="3"><li>Same as global variables</li></ol><ol type="a" id="f2e80765-5472-42c0-8b1a-f00ae3b261e4" class="numbered-list" start="4"><li>These are declared outside any function and are available throughout the lifetime of the program</li></ol><ol type="a" id="8ccce485-e109-48de-86d6-66bd0f78a1a5" class="numbered-list" start="5"><li>int x written outside function will tell that it’s global to that function</li></ol><ol type="a" id="c083f9e5-f7a9-46fe-a274-ee56162c30f4" class="numbered-list" start="6"><li>Extern is used to declaring a variable that is declared somewhere else</li></ol><ol type="a" id="ab23aa82-e42d-4e51-a544-2f4713ccc088" class="numbered-list" start="7"><li>Using an extern will not allocate space for the variable</li></ol></li></ol><ol type="1" id="f3cf1cd3-25a5-473c-91df-32aabc06cfb1" class="numbered-list" start="6"><li><strong>Static</strong> Variables<ol type="a" id="feb14e33-514f-4973-a762-c1eefcae447a" class="numbered-list" start="1"><li>Local to the block of code they are in</li></ol><ol type="a" id="172c5ec7-44c3-490a-9625-1a6ba66375c9" class="numbered-list" start="2"><li>Initial value 0</li></ol><ol type="a" id="2eb56d8c-8d6c-4784-8aa0-4adf039ecf9f" class="numbered-list" start="3"><li>They are available throughout the lifetime of the program</li></ol></li></ol><ol type="1" id="97516768-54a9-40b3-a41f-fae689c0f24f" class="numbered-list" start="7"><li><strong>Register</strong> Variables<ol type="a" id="73704bc3-3ffd-4695-9675-5cc1bb9c3ec3" class="numbered-list" start="1"><li>Local to the function they are defined in</li></ol><ol type="a" id="5121a9ef-476a-452d-a4d9-c0033efcd9c5" class="numbered-list" start="2"><li>Initial value garbage</li></ol><ol type="a" id="27a9f55c-7c1e-494c-b917-28843e6f4fa7" class="numbered-list" start="3"><li>Stores in CPU register instead of the memory</li></ol><ol type="a" id="d9df6e7f-994a-46d2-8208-c57207c90ba5" class="numbered-list" start="4"><li>Can’t get the address</li></ol></li></ol><figure id="f3bbf686-8bf4-412a-a479-9f599a8a6ef3" class="image"><a href="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image7.png"><img style="width:650px" src="C%20Programming%20Notes%2093b6bc764c3f4836995d4316f2674556/image7.png"/></a></figure><h2 id="4dc17f58-2028-4120-80ad-aa1bcc55ce6e" class="">Important Stuff</h2><pre id="1180973e-309b-48da-99b3-72b48345947f" class="code"><code>#include &lt;stdio.h&gt;

int main()

{

    int a = 10, b = 20;

    fun(&amp;a, &amp;a, &amp;b);

    printf(&quot;%d&quot;, a + b);

    return 0;
}

int fun(int *x, int *y, int *z) // 10 10 20

{

    -x = *x + *y + *z; // 40 40 20

    printf(&quot;%d %d %d\n&quot;, *x, *y, *z);

    x = y; // 40 40 20

    printf(&quot;%d %d %d\n&quot;, *x, *y, *z);

    y = z; // 40 20 20

    printf(&quot;%d %d %d\n&quot;, *x, *y, *z);

    z = x; // 40 20 40

    printf(&quot;%d %d %d\n&quot;, *x, *y, *z);

    x = z; // 40 20 40

    printf(&quot;%d %d %d\n&quot;, *x, *y, *z);

    x++; // 20 20 40

    printf(&quot;%d %d %d\n&quot;, *x, *y, *z);

    -x = *x + 10; // 30 30 40

    printf(&quot;%d %d %d\n&quot;, *x, *y, *z);

    return 0;
}</code></pre><h2 id="6f5da12a-2783-4163-8e9a-2c1786ce3d25" class="">Exam Tips:</h2><ul id="ff18f20b-77d1-4cf0-b304-f9fc84974f99" class="bulleted-list"><li style="list-style-type:disc">Read Question Properly</li></ul><ul id="ea4a1a07-7edf-48a7-b762-60e4a321e28c" class="bulleted-list"><li style="list-style-type:disc">Mark Correct Option</li></ul><ul id="a1f5a9dc-2964-4e96-9e87-fb3aa8b191a2" class="bulleted-list"><li style="list-style-type:disc">Preference Orders</li></ul><ul id="5ef5c67d-a0f6-4778-af5b-04e57551a73c" class="bulleted-list"><li style="list-style-type:disc">Don’t miss semicolons</li></ul><ul id="1943981f-9838-4441-8991-b8af0312d510" class="bulleted-list"><li style="list-style-type:disc">Don’t miss &amp;s</li></ul></div></article></body></html>