<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Ch 8: Main Memory (RAM) Management</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="88d38d08-333f-405b-867e-e9809ab26a4e" class="page sans"><header><h1 class="page-title">Ch 8: Main Memory (RAM) Management</h1><p class="page-description"></p></header><div class="page-body"><nav id="289a52d5-3011-4851-8e1f-55d6378cddbd" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4b1e3b7c-9ae4-48f1-8064-3733fe1ae7a5">Introduction</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#203be2e9-5f0d-40cb-a323-88ac413f0e6d">Base and Limit Registers</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7c2ef3ac-43f2-4d9d-98dc-e82234117dbe">Logical vs Physical Address Space</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#648129d9-a01e-48f5-acbe-717f5b855922">Memory Management Unit</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#a850568e-0c9d-40ed-bb14-63af62af3af1">Dynamic Loading</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d198c5d8-b91e-4ef1-8eb0-5ea43ff25e82">Swapping</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9c482929-b1fc-42b9-9a4e-d5a043004923">Contiguous Memory Allocation</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9cd65bea-d1ea-4de4-9968-1e06b5499bae">Multiple Partition Allocation</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#39292775-4d0b-4b99-a486-5c9e214fef94">Dynamic Storage Allocation Problem</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#81c84772-1331-448b-8ed1-983b1b5d76df">Question</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8022482d-05ee-4ee4-96f8-9ff4219a1e97">Fragmentation</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4db072a1-76e5-451e-a446-91825c50004f">1. Segmentation Architecture</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5c001a7b-3652-41b7-b9c8-3cd62539c22f">2. Paging</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c6106654-3244-4cf8-a6ff-7ea8f3116286">Address Translation Scheme</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6249394e-2431-4754-a659-28913b447b3f">Paging Hardware</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#772d76c5-4e32-4ccc-9b57-a45eb1a93f5d">Disadvantages</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#72835609-afd1-4c87-9e7d-544f4aaa52f1">Free Frames</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#17055a1d-93e0-4768-afb0-7997f683c304">Page Table Implementation</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#20d7b30b-49ec-4a69-a4ac-df9f7fef3287">Effective Access Time</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#02cf3edb-2495-4006-82f1-3a8e15dd2445">Example</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e33d8841-1a24-4105-889f-23d28aef640e">Memory Protection</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6ac157f4-46d2-436a-96bd-761367cd0152">Page Table Structure</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#24ff3353-8712-4112-ae85-20ff23954f2d">A. Hierarchical Paging</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b0b31fb3-0d9a-433b-a001-d9d2222a5a52">B. Hashed Page Tables</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#62d9a056-7662-4692-9e0e-72987ef43569">C. Inverted Page Tables</a></div></nav><h1 id="4b1e3b7c-9ae4-48f1-8064-3733fe1ae7a5" class="">Introduction</h1><ul id="da1d9db3-6c7a-43e6-9f3c-ff15bae21f47" class="bulleted-list"><li style="list-style-type:disc">Program must be brought into memory</li></ul><ul id="c388d47b-9b5b-46ba-960a-5d798e2cc001" class="bulleted-list"><li style="list-style-type:disc">It has to be in the main memory for execution</li></ul><ul id="3850fcc0-5f89-46d0-93cb-0b400c6cafa1" class="bulleted-list"><li style="list-style-type:disc">Secondary storage is where things are retained after off</li></ul><ul id="bbc6fcc2-8013-4d28-92a8-f09ba4e4cf9e" class="bulleted-list"><li style="list-style-type:disc">Main memory and registers are only storage CPU can access directly</li></ul><ul id="327c4b51-c8f7-4ca1-99c1-c9792c090682" class="bulleted-list"><li style="list-style-type:disc">Memory unit only sees a stream of addresses + read requests or address + data and write requests</li></ul><ul id="42923c28-5530-4d8c-a28b-899aed9ff706" class="bulleted-list"><li style="list-style-type:disc">Main memory can take many cycles causing stalls</li></ul><ul id="9f224798-1a20-438a-ad21-cc03487901cb" class="bulleted-list"><li style="list-style-type:disc">Cache sits between main memory and CPU registers</li></ul><h1 id="203be2e9-5f0d-40cb-a323-88ac413f0e6d" class="">Base and Limit Registers</h1><ul id="d2dfc2ea-93d1-4f69-ab08-f5aae33867bb" class="bulleted-list"><li style="list-style-type:disc">A pair of base and limit registers define the address space</li></ul><ul id="083c73b3-48f0-4bff-b41a-92b759fc632f" class="bulleted-list"><li style="list-style-type:disc">Base Register → value of the smallest legal physical address that a process can access</li></ul><ul id="1017146a-216f-41dd-af95-8c4da149d839" class="bulleted-list"><li style="list-style-type:disc">Limit Register → size of the range</li></ul><ul id="2e81427b-0863-4480-ab88-5fa60afadc59" class="bulleted-list"><li style="list-style-type:disc">Largest will be base + limit - 1</li></ul><ul id="058b9d3d-b5ca-4a7b-9ff6-e21ac0cd71ed" class="bulleted-list"><li style="list-style-type:disc">CPU must check every memory access generated in user mode to be sure it is between base and limit of that user</li></ul><ul id="003e8819-f84f-4177-96f4-9de971cc4797" class="bulleted-list"><li style="list-style-type:disc">These are registers per process</li></ul><figure id="3a95ede8-d288-4966-9338-c0cbcc87a5a9" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled.png"><img style="width:1488px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled.png"/></a></figure><h1 id="7c2ef3ac-43f2-4d9d-98dc-e82234117dbe" class="">Logical vs Physical Address Space</h1><ul id="39bc36d7-2777-448a-844e-20bb5b00aba8" class="bulleted-list"><li style="list-style-type:disc">Logical Address - generated by the CPU also referred to as virtual address</li></ul><ul id="b5125819-f075-440d-a207-d4e9578b05a5" class="bulleted-list"><li style="list-style-type:disc">Physical Address - the actual address of the memory location</li></ul><ul id="96339110-dd8f-492b-8730-a594230b2c6b" class="bulleted-list"><li style="list-style-type:disc">Logical address space - set of all logical addresses generated by a program</li></ul><ul id="1179fcb3-a569-46fa-8565-362acd236257" class="bulleted-list"><li style="list-style-type:disc">Physical address space - set of all physical addresses</li></ul><ul id="c267845b-a19f-4c2d-91d4-a84731c764fe" class="bulleted-list"><li style="list-style-type:disc">You do not give the actual physical address to the user</li></ul><ul id="4bce0d7f-b8e1-4d96-af54-d1059ab416a8" class="bulleted-list"><li style="list-style-type:disc">If I am a malicious user, i can make wrong use of this</li></ul><ul id="ef1726dc-b4f4-43f3-8da3-afd436558a46" class="bulleted-list"><li style="list-style-type:disc">We map logical addresses to the physical addresses</li></ul><h1 id="648129d9-a01e-48f5-acbe-717f5b855922" class="">Memory Management Unit</h1><ul id="f6f61a46-877a-4183-a896-f85237b3cc43" class="bulleted-list"><li style="list-style-type:disc">Hardware device that at run time maps virtual address to physical address</li></ul><ul id="89c26651-b279-469c-9fb9-6008e98cd87a" class="bulleted-list"><li style="list-style-type:disc">The user program deals with logical addresses, it never sees the real physical addresses</li></ul><figure id="f15438b9-c1df-4fb9-ac88-5424880fd635" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%201.png"><img style="width:432px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%201.png"/></a></figure><h1 id="a850568e-0c9d-40ed-bb14-63af62af3af1" class="">Dynamic Loading</h1><ul id="0b25899d-2488-4aac-9247-588c84079a14" class="bulleted-list"><li style="list-style-type:disc">Routine is not loaded until it is called</li></ul><ul id="313180c3-434b-43d9-aac9-9da710ea9088" class="bulleted-list"><li style="list-style-type:disc">Better memory space utilization, unused routine is never loaded</li></ul><ul id="31e78a88-77b9-454f-bbe1-232bc3efbe98" class="bulleted-list"><li style="list-style-type:disc">All routines kept on disk</li></ul><ul id="72bc8662-446c-45c0-9819-bd5d41c7183c" class="bulleted-list"><li style="list-style-type:disc">Useful when large amounts of code are needed to handle infrequently occurring cases</li></ul><ul id="6ee1b368-c391-4268-a1b1-75f5d486c271" class="bulleted-list"><li style="list-style-type:disc">We can increase degree of multiprogramming</li></ul><ul id="587df139-71c2-479e-90c0-a2eb932b23b6" class="bulleted-list"><li style="list-style-type:disc">Routines = Functions = Procedures</li></ul><h1 id="d198c5d8-b91e-4ef1-8eb0-5ea43ff25e82" class="">Swapping</h1><ul id="f6e3ee2b-f486-4c26-a068-83f5e89b2585" class="bulleted-list"><li style="list-style-type:disc">A process can be swapped temporarily out of memory to a backing store and then brought back into memory for continued execution </li></ul><ul id="91c6980c-e874-42ce-9606-9d3b266ccfc5" class="bulleted-list"><li style="list-style-type:disc">Total physical memory space of processes can exceed physical memory</li></ul><ul id="ce5bf60c-825d-4686-b3de-33bafdd57b9b" class="bulleted-list"><li style="list-style-type:disc">Backing store → fast disk large enough to accommodate copies of all memory images for all users</li></ul><ul id="6186b46a-4249-46d5-95ec-0b409c9895e7" class="bulleted-list"><li style="list-style-type:disc">Major part of swap time is transfer time</li></ul><ul id="208289d7-9ba3-4f73-ad6a-831e1d7003d3" class="bulleted-list"><li style="list-style-type:disc">System maintains a ready queue of ready to run processes which have memory images on disk</li></ul><ul id="443f97b2-43a0-4edd-98ff-79d948d5c6e9" class="bulleted-list"><li style="list-style-type:disc">Swap only when free memory extremely low</li></ul><ul id="7ad09acf-de81-4c32-8bc3-2368beedb9a7" class="bulleted-list"><li style="list-style-type:disc">Swapping portions of processes</li></ul><ul id="cae9b494-b580-4697-b9fd-81b1aba7fd23" class="bulleted-list"><li style="list-style-type:disc">Rate at which you access memory is faster than the rate at which you access disk</li></ul><ul id="4eeeb83c-0101-4b78-b725-78f580a8f762" class="bulleted-list"><li style="list-style-type:disc">Context switch time can then be very high</li></ul><ul id="ed2a5a53-243c-4b6e-8f71-b69196544218" class="bulleted-list"><li style="list-style-type:disc">Swapping has overhead</li></ul><ul id="bda742a6-ea53-4174-bc67-e4187373527b" class="bulleted-list"><li style="list-style-type:disc">If next processes to be put on CPU is not in memory, need to swap out a process and swap in a target process</li></ul><ul id="e7b3e1e8-1252-4965-b939-7ed7449ebe00" class="bulleted-list"><li style="list-style-type:disc">100MB process swapping to hard disk with transfer rate of 50MB/s<ul id="8808a09b-f02d-4955-8657-7c2ab70d1dd2" class="bulleted-list"><li style="list-style-type:circle">Swap out time of 2000ms</li></ul><ul id="a1492a0b-dcba-4f35-86c4-a3ae1b3b5132" class="bulleted-list"><li style="list-style-type:circle">Plus swap in of same sized process</li></ul><ul id="0588cce8-2efe-448a-8803-b04b5eb6e426" class="bulleted-list"><li style="list-style-type:circle">Total context switch swapping component time of 4000ms</li></ul></li></ul><figure id="fab72fed-edff-4968-bd1f-a960f9bde655" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%202.png"><img style="width:480px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%202.png"/></a></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="00997b04-39e8-4ccb-ab2f-a7b3af3e6605"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Why is swap space not dynamic but rather it is fixed</div></figure><h1 id="9c482929-b1fc-42b9-9a4e-d5a043004923" class="">Contiguous Memory Allocation</h1><ul id="d1a62ba7-cd54-4018-9060-3c8b80524868" class="bulleted-list"><li style="list-style-type:disc">Relocation registers used to protect user processes from each other and from changing OS code and data</li></ul><ul id="9b6819d7-e679-463d-a70a-f45e96db267a" class="bulleted-list"><li style="list-style-type:disc">Relocation register contains value of smallest physical address</li></ul><ul id="59fe5838-43bb-48df-a167-d6c3169bae91" class="bulleted-list"><li style="list-style-type:disc">Limit register contains range of logical addresses - each logical address must be <span style="border-bottom:0.05em solid">less than</span> the limit register</li></ul><ul id="da0182f9-12dd-4933-828c-8df96383ef03" class="bulleted-list"><li style="list-style-type:disc">MMU maps logical address dynamically</li></ul><figure id="c5e83a56-132b-4428-9846-b4b377ba6171" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%203.png"><img style="width:1335px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%203.png"/></a></figure><h1 id="9cd65bea-d1ea-4de4-9968-1e06b5499bae" class="">Multiple Partition Allocation</h1><ul id="fbf42222-d3dd-4857-9349-2c7b24c20465" class="bulleted-list"><li style="list-style-type:disc">Fixed size partitions, degree of multiprogramming limited by number of partitions</li></ul><ul id="fcdba59b-1f99-4601-81ae-b3c621382b15" class="bulleted-list"><li style="list-style-type:disc">Variable partition sizes for efficiency → sized to a given process’s needs</li></ul><ul id="e319f210-7c14-4b62-9c03-eb0f1363af28" class="bulleted-list"><li style="list-style-type:disc">Hole → block of available memory, holes of various size are scattered throughout memory</li></ul><ul id="e8c3c923-a067-4a52-a1fe-b7ad158bf77a" class="bulleted-list"><li style="list-style-type:disc">When a process arrives, it is allocated memory from a hole large enough to accommodate it</li></ul><ul id="4698bac0-7636-4b30-8d1b-8cec930adaa9" class="bulleted-list"><li style="list-style-type:disc">Process exiting frees its partition, adjacent free partitions combined</li></ul><ul id="71559745-2757-4a16-84c7-54ffce868014" class="bulleted-list"><li style="list-style-type:disc">OS maintains info about <ul id="58333696-c27f-4e31-893e-f2572f09efb2" class="bulleted-list"><li style="list-style-type:circle">allocated partitions</li></ul><ul id="70f9ca45-d80c-4957-9ff7-9b3e34993da2" class="bulleted-list"><li style="list-style-type:circle">free partitions</li></ul></li></ul><figure id="34952f4d-284d-434b-9927-425c6feddf8b" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%204.png"><img style="width:1170px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%204.png"/></a></figure><h1 id="39292775-4d0b-4b99-a486-5c9e214fef94" class="">Dynamic Storage Allocation Problem</h1><ul id="a37245f4-425d-4ffa-93ca-4776c5e39225" class="bulleted-list"><li style="list-style-type:disc">How to satisfy a request of size n from a list of free holes?</li></ul><ul id="a41b3c52-851f-4f6f-b982-9622b4699c4e" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid">First fit → Allocate the first hole that is big enough</span></li></ul><ul id="10ce3195-0345-4843-8e20-0f1110bfe2ff" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid">Best fit → Allocate the smallest hole that is big enough, must search entire list, unless ordered by size</span><ul id="c0059348-4852-42b9-b814-1a0ee84f9810" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid">Produces smallest leftover hole</span></li></ul></li></ul><ul id="6a166753-e48b-4235-9740-bd2f55b40c74" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid">Worst fit → allocate the largest hole, must also search entire list</span><ul id="7e059a36-3c78-4b13-a0f1-084ae450640c" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid">Produces the largest leftover hole</span></li></ul></li></ul><ul id="4a2d60af-50b7-400a-9969-1eb92365bcbd" class="bulleted-list"><li style="list-style-type:disc">First fit and best fit better than worst fit in terms of speed and storage utilization</li></ul><h2 id="81c84772-1331-448b-8ed1-983b1b5d76df" class="">Question</h2><ul id="94a8f801-13a8-47ec-82a3-cfc3e1c8a33e" class="bulleted-list"><li style="list-style-type:disc">Given 6 partitions of 300KB, 600KB, 350KB, 200KB, 750KB and 125KB <span style="border-bottom:0.05em solid">in order</span>. How many first fit, best fit and worst fit algorithms place the processes of size <span style="border-bottom:0.05em solid"><em>115KB, 500KB, 358KB, 200KB, 375KB</em></span> <span style="border-bottom:0.05em solid">in order</span></li></ul><ul id="a1cc4714-b94f-4ada-b1fc-e5466b3a543b" class="bulleted-list"><li style="list-style-type:disc">Note when hole is created it is treated as independent partition</li></ul><ul id="39c0e485-bde5-40e2-9846-be331555c5f9" class="bulleted-list"><li style="list-style-type:disc">First fit </li></ul><table id="fc3444fc-818f-4a63-9924-2a9fa4992206" class="simple-table"><tbody><tr id="ee28c7c6-4d48-46df-ab07-497c5e6b6530"><td id="SDW?" class="">300KB-<span style="border-bottom:0.05em solid">115KB</span></td><td id="XqX]" class="">600KB-<span style="border-bottom:0.05em solid">500KB</span></td><td id="aKmc" class="">350KB-<span style="border-bottom:0.05em solid">200KB</span></td><td id="uAVj" class="">200KB</td><td id="bHsi" class="">750KB-<span style="border-bottom:0.05em solid">358KB</span></td><td id="~Bxs" class="">125KB</td></tr><tr id="4d1efa94-2723-4cc8-b8e4-9b685ee64823"><td id="SDW?" class="">185KB</td><td id="XqX]" class="">100KB</td><td id="aKmc" class="">150KB</td><td id="uAVj" class="">200KB</td><td id="bHsi" class="">392KB-<span style="border-bottom:0.05em solid">375KB</span></td><td id="~Bxs" class="">125KB</td></tr></tbody></table><ul id="3c3a995f-9965-4c2f-b91a-de09463a40cf" class="bulleted-list"><li style="list-style-type:disc">Best fit</li></ul><table id="3f890e83-a903-4faa-aef4-89ce4be1317e" class="simple-table"><tbody><tr id="365d6fa5-d140-47c1-bd4f-111445388c42"><td id="SDW?" class="">300KB</td><td id="XqX]" class="">600KB-<span style="border-bottom:0.05em solid">500KB</span></td><td id="aKmc" class="">350KB</td><td id="uAVj" class="">200KB-<span style="border-bottom:0.05em solid">200KB</span></td><td id="bHsi" class="">750KB-<span style="border-bottom:0.05em solid">358KB</span></td><td id="~Bxs" class="">125KB-<span style="border-bottom:0.05em solid">115KB</span></td></tr><tr id="5f960256-61de-4dfa-83dc-e60e90fefd04"><td id="SDW?" class="">300KB</td><td id="XqX]" class="">100KB</td><td id="aKmc" class="">350KB</td><td id="uAVj" class="">0KB</td><td id="bHsi" class="">392KB-<span style="border-bottom:0.05em solid">375KB</span></td><td id="~Bxs" class="">10KB</td></tr></tbody></table><ul id="fd47b6e4-2684-417d-b883-1038d01d08fd" class="bulleted-list"><li style="list-style-type:disc">Worst fit - 375KB will not have a slot</li></ul><table id="be50c44d-0ad4-4741-bb4b-d9746f3624c5" class="simple-table"><tbody><tr id="869f42a6-be6f-4777-a402-4d8e84c419d6"><td id="SDW?" class="">300KB</td><td id="XqX]" class="">600KB</td><td id="aKmc" class="">350KB</td><td id="uAVj" class="">200KB</td><td id="bHsi" class="">750KB-115KB</td><td id="~Bxs" class="">125KB</td></tr><tr id="861d2724-def0-4b05-9f49-62da5288a2ac"><td id="SDW?" class="">300KB</td><td id="XqX]" class="">600KB</td><td id="aKmc" class="">350KB</td><td id="uAVj" class="">200KB</td><td id="bHsi" class="">635KB-500KB</td><td id="~Bxs" class="">125KB</td></tr><tr id="f43344a9-e16d-4999-a2f0-95c5fe3fbbd5"><td id="SDW?" class="">300KB</td><td id="XqX]" class="">600KB-358KB</td><td id="aKmc" class="">350KB</td><td id="uAVj" class="">200KB</td><td id="bHsi" class="">135KB</td><td id="~Bxs" class="">125KB</td></tr><tr id="d513d195-ef61-439f-894d-8d663679cb41"><td id="SDW?" class="">300KB</td><td id="XqX]" class="">242KB</td><td id="aKmc" class="">350KB-200KB</td><td id="uAVj" class="">200KB</td><td id="bHsi" class="">135KB</td><td id="~Bxs" class="">125KB</td></tr><tr id="0949791a-e9af-4947-af2e-4dd079c6467a"><td id="SDW?" class="">300KB</td><td id="XqX]" class="">242KB</td><td id="aKmc" class="">150KB</td><td id="uAVj" class="">200KB</td><td id="bHsi" class="">135KB</td><td id="~Bxs" class="">125KB</td></tr></tbody></table><h1 id="8022482d-05ee-4ee4-96f8-9ff4219a1e97" class="">Fragmentation</h1><ul id="4efb0a32-8523-4f60-bd39-25cfa076de5d" class="bulleted-list"><li style="list-style-type:disc"><em><strong>External fragmentation</strong></em> - total memory space exists to satisfy a request but it is not contiguous</li></ul><ul id="e2da6010-22ae-4bcf-9fce-e8807817b96d" class="bulleted-list"><li style="list-style-type:disc">Reduce <span style="border-bottom:0.05em solid">external fragmentation by compaction</span></li></ul><ul id="9c2555f1-dfb3-411d-90dd-50fe865a4514" class="bulleted-list"><li style="list-style-type:disc">Shuffle memory contents to place all free memory together in one large block</li></ul><ul id="6168a405-7464-44c0-b704-cec0b7ed6b57" class="bulleted-list"><li style="list-style-type:disc">Allow logical address space of processes to be non contiguous</li></ul><ul id="5e32f9f8-dc8c-4541-85fe-a419715883cf" class="bulleted-list"><li style="list-style-type:disc"><em><strong>Internal fragmentation</strong></em> - allocated memory may be slightly larger than requested memory - this size difference is memory internal to a partition but not being used</li></ul><ul id="e4d3ea9a-b43e-451a-a100-48058b450878" class="bulleted-list"><li style="list-style-type:disc">Happens cause if we have blocks of 20kb each but if we have a process 65kb we need to give 8 blocks and cannot proceed with 65kb</li></ul><h1 id="4db072a1-76e5-451e-a446-91825c50004f" class="">1. Segmentation Architecture</h1><ul id="95fc562e-34c1-47ec-985c-513bcb6a8fec" class="bulleted-list"><li style="list-style-type:disc">A program is a collection of variable sized segments</li></ul><ul id="f5af0179-d495-4206-a5a4-a547aa3184f8" class="bulleted-list"><li style="list-style-type:disc">A segment is a logical unit such as main program, procedure, function, method, object, local , variables, global variables, stack, symbol table, arrays</li></ul><ul id="5314455d-746a-4f73-bcc5-7fdd2eb022f8" class="bulleted-list"><li style="list-style-type:disc">Memory management scheme that supports user view of memory</li></ul><ul id="b50921db-1ef0-457d-b8dd-7ac74111d924" class="bulleted-list"><li style="list-style-type:disc">Logical address space is a collection of segments</li></ul><figure id="9c51bfa2-544f-4c88-b109-8a6ee320b617" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%205.png"><img style="width:240px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%205.png"/></a></figure><ul id="817f66f3-c68d-433b-936d-1f86c5cf556c" class="bulleted-list"><li style="list-style-type:disc">Logical address consists of a two tuple: &lt;segment number, offset&gt;</li></ul><ul id="d981433b-5909-4363-a760-199a45625846" class="bulleted-list"><li style="list-style-type:disc">Segment table → maps logical addresses to physical addresses → each table entry has<ul id="ee7bf8aa-b964-4df2-9edf-be248b1ed6ea" class="bulleted-list"><li style="list-style-type:circle">Segment base - contains the starting physical address where the segment resides in memory</li></ul><ul id="5187cfb4-2545-43c2-a9eb-17ab038a5aeb" class="bulleted-list"><li style="list-style-type:circle">segment limit - specifies the length of the segment</li></ul></li></ul><ul id="9b5c9d46-70a3-49c0-ab8a-5da8f547cdc0" class="bulleted-list"><li style="list-style-type:disc">Segment table base register → points to the segment table’s location in memory</li></ul><ul id="3c764963-e2e6-4d66-86fe-52966e5098ec" class="bulleted-list"><li style="list-style-type:disc">Segment table length register → indicates number of segments used by a program</li></ul><figure id="3a6390a9-8c02-4335-887e-66ed0dc1fc35" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%206.png"><img style="width:1942px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%206.png"/></a></figure><ul id="b00f99ad-987f-40c9-9d50-266c11faf9b2" class="bulleted-list"><li style="list-style-type:disc">We cannot go to &lt;3, 1100&gt; → This is invalid because the offset cannot be equal to limit</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="acba6425-f00a-4482-b41b-599729e3afbf"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">NOTE: Assume segments are numbered from 0</div></figure><h1 id="5c001a7b-3652-41b7-b9c8-3cd62539c22f" class="">2. Paging</h1><ul id="dad39731-7e23-49da-87a5-e111dbb93ccc" class="bulleted-list"><li style="list-style-type:disc">Physical address space of a process can be non contiguous</li></ul><ul id="a71d049e-e7ad-4739-a08c-d67c548445bd" class="bulleted-list"><li style="list-style-type:disc">Process is allocated physical memory whenever the latter is available<ul id="00aaa82d-cbc1-4741-bd9e-6e414f60695f" class="bulleted-list"><li style="list-style-type:circle">Avoids external fragmentation → Avoids need for compaction</li></ul></li></ul><ul id="83c6ced6-732a-4d78-8c76-80d51f58306d" class="bulleted-list"><li style="list-style-type:disc">Divide physical memory into fixed sized blocks called frames<ul id="ff18cb59-e5ac-45c4-9a4b-114357082de2" class="bulleted-list"><li style="list-style-type:circle">Size is power of 2</li></ul></li></ul><ul id="1cf74dc3-7e28-4fcf-b815-83b917794a4e" class="bulleted-list"><li style="list-style-type:disc">Divide logical memory into blocks of same size called pages</li></ul><ul id="ff16aae3-5496-4508-adeb-779d29e2973b" class="bulleted-list"><li style="list-style-type:disc">Keep track of all free frames</li></ul><ul id="1482d96b-4ae3-4716-be07-3b628a50a698" class="bulleted-list"><li style="list-style-type:disc">To run a program of size N pages, need to find N free frames and load program</li></ul><ul id="cb873353-bf49-4a7e-b4de-308e261e8f16" class="bulleted-list"><li style="list-style-type:disc">Set up a page table to translate logical to physical addresses</li></ul><ul id="399de7f3-8461-4443-9f39-7c475d9fdbfc" class="bulleted-list"><li style="list-style-type:disc">Still have internal fragmentation</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="9b9faad7-4793-455f-b7d7-6fe1d0b144ed"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">You need to use 1024 in exam and not 1000</div></figure><ul id="ecd4b101-00b5-46eb-93c8-0874e8d91eb7" class="bulleted-list"><li style="list-style-type:disc">Pages are per process but frame is across all processes</li></ul><figure id="3b36215d-14f5-4947-8091-a2732f5dfdb3" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%207.png"><img style="width:1666px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%207.png"/></a></figure><h2 id="c6106654-3244-4cf8-a6ff-7ea8f3116286" class="">Address Translation Scheme</h2><ul id="43f33e4c-d2a1-425e-bce1-83ff4da7b696" class="bulleted-list"><li style="list-style-type:disc">Address generated by CPU is divided into:<ul id="cb375cf8-1d98-4e13-9c6a-db500a135322" class="bulleted-list"><li style="list-style-type:circle">Page Number(p) → used as an index into a page table which contains base address of each page in physical memory</li></ul><ul id="a528c38e-c98d-418c-978d-decf65c5f5fd" class="bulleted-list"><li style="list-style-type:circle">Page offset(d) → combined with base address to define the physical memory address that is sent to the memory unit<table id="0e0ab6b9-3e1a-4e95-9a18-f9000f8847f0" class="simple-table"><tbody><tr id="46f33997-53dd-4c73-b47a-e03fe50f7382"><td id="}J^Q" class="">Page number</td><td id="rSt}" class="">Page offset</td></tr><tr id="219b3924-c129-4bcb-b143-aaf81b851b90"><td id="}J^Q" class="">p</td><td id="rSt}" class="">d</td></tr><tr id="622467dc-8676-4417-a438-f8080b8bdcca"><td id="}J^Q" class="">m-n</td><td id="rSt}" class="">n</td></tr></tbody></table></li></ul></li></ul><ul id="57df72f1-8731-4e69-9a50-b3d0b0b01e09" class="bulleted-list"><li style="list-style-type:disc">Logical address space 2^m bytes and page size 2^n bytes</li></ul><h2 id="6249394e-2431-4754-a659-28913b447b3f" class="">Paging Hardware</h2><figure id="b4cae0e0-e768-415b-8a98-b041d2b93a71" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%208.png"><img style="width:2040px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%208.png"/></a></figure><figure id="b9637932-78a3-43d4-b57a-07135ab4aafd" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%209.png"><img style="width:1532px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%209.png"/></a></figure><figure id="03776a76-e1ee-49bf-bfce-e8c4743551ee" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2010.png"><img style="width:1758px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2010.png"/></a></figure><ul id="f32a4a19-7e51-410d-a737-025a35132a05" class="bulleted-list"><li style="list-style-type:disc">Memory given to a process is non contiguous</li></ul><ul id="3a2dcfc2-bb87-4ae5-b6c9-d89424200a64" class="bulleted-list"><li style="list-style-type:disc">Address will be m bit, if page offset is n bit, page number is m-n bit</li></ul><h2 id="772d76c5-4e32-4ccc-9b57-a45eb1a93f5d" class="">Disadvantages</h2><ul id="8ca16cd2-a76c-41a5-97ca-5afcbfa418bc" class="bulleted-list"><li style="list-style-type:disc">Prone to Internal fragmentation</li></ul><ul id="07ecec9f-4b1b-431e-97b6-d6cd6007cc19" class="bulleted-list"><li style="list-style-type:disc">So small frame sizes desirable</li></ul><ul id="bd003357-a718-4c24-9afd-4a4ce1572706" class="bulleted-list"><li style="list-style-type:disc">But each page table entry takes memory to track</li></ul><ul id="ffda0573-177b-4f68-923b-cdd8dc1e21b1" class="bulleted-list"><li style="list-style-type:disc">Typically on modern day architectures, the page size was 4096 → 4KB</li></ul><figure id="71380573-3b00-4568-a704-8a04957a3e37" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2011.png"><img style="width:432px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2011.png"/></a></figure><h2 id="72835609-afd1-4c87-9e7d-544f4aaa52f1" class="">Free Frames</h2><ul id="71ff3cc9-e180-42ee-bd2a-3adbe6caa79a" class="bulleted-list"><li style="list-style-type:disc">Frame table → one entry for each frame indicating whether the frame is free or allocated and if allocated, to which page of which process</li></ul><figure id="95068fd7-2c28-4537-a37f-c41e1c758905" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2012.png"><img style="width:2361px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2012.png"/></a></figure><h1 id="17055a1d-93e0-4768-afb0-7997f683c304" class="">Page Table Implementation</h1><ul id="69779cba-16e0-479a-860b-f4bc117904d5" class="bulleted-list"><li style="list-style-type:disc">Page table is kept in main memory</li></ul><ul id="26ac8e3b-e092-4eeb-be4b-54ada16ced18" class="bulleted-list"><li style="list-style-type:disc">Page table base register - PTBR points to the page table</li></ul><ul id="51f36395-bee1-4b13-8600-87e927640bf3" class="bulleted-list"><li style="list-style-type:disc">Page table length register - PTLR indicates size of the page table </li></ul><ul id="ac0e2354-c97c-43b6-928a-3463277e1445" class="bulleted-list"><li style="list-style-type:disc">Need privileged instructions to run PTBR and PTLR</li></ul><ul id="1a912027-7c6a-438a-9998-5236b3b71704" class="bulleted-list"><li style="list-style-type:disc">No user program is allowed to modify the value of this</li></ul><ul id="db032d99-d98d-4539-987d-069df71e5d79" class="bulleted-list"><li style="list-style-type:disc">In this scheme every data/instruction access requires two memory accesses</li></ul><ul id="cba85464-f9d4-43ba-a643-822d202baf38" class="bulleted-list"><li style="list-style-type:disc">One for the page table and one for the data or instruction</li></ul><ul id="fefc161a-dde5-469e-889f-7ee666341458" class="bulleted-list"><li style="list-style-type:disc">The two memory access problem can be solved by the use of a special fast lookup hardware cache called associative memory or <span style="border-bottom:0.05em solid">translation look aside buffers</span></li></ul><ul id="fe7ed195-8633-4f9f-af16-9f51df867242" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid">Associative memory</span> allows us to do a parallel search where we have key value pairs of page# and frame# respectively</li></ul><ul id="a8d9c65b-0536-4924-ae6e-dd8996369a80" class="bulleted-list"><li style="list-style-type:disc">Address translation(p, d)<ul id="fe8a53f2-7943-43e0-90b6-f851975f0cb2" class="bulleted-list"><li style="list-style-type:circle">If p is in associative memory, get frame # out → this is called a <code>TLB Hit</code></li></ul><ul id="6bb753c5-863d-4d77-8a2a-209814f97f4e" class="bulleted-list"><li style="list-style-type:circle">Otherwise get frame # from page table in memory</li></ul></li></ul><figure id="e4cce585-c7a1-4313-95b2-63ef266871c3" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2013.png"><img style="width:576px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2013.png"/></a></figure><h2 id="20d7b30b-49ec-4a69-a4ac-df9f7fef3287" class="">Effective Access Time</h2><ul id="c2b2df27-0fe8-4415-8558-1a1cb6e2bf8a" class="bulleted-list"><li style="list-style-type:disc">Associative lookup = e time unit</li></ul><ul id="45263378-bd08-494e-aeab-d2f29c5a933d" class="bulleted-list"><li style="list-style-type:disc">Hit ratio = alpha<ul id="f20705c9-8635-475b-8689-22a9fe73880c" class="bulleted-list"><li style="list-style-type:circle">Hit ratio - percentage of times that a page number is found in the associative memory</li></ul></li></ul><ul id="73e241e8-c2c0-4bdb-a31c-e85139101504" class="bulleted-list"><li style="list-style-type:disc">Consider alpha = 80%, e = 20ns for TLB search, 100ns for memory access</li></ul><ul id="0b37608d-7cc5-4046-8604-8662fa606697" class="bulleted-list"><li style="list-style-type:disc">EAT will come out to be 0.8 * 120 + 0.2 * 220</li></ul><ul id="d0cefacc-dfbc-454b-99bb-9f2b9f92d6ed" class="bulleted-list"><li style="list-style-type:disc">This means 80% time we get TLB hits so only one memory access</li></ul><ul id="95329bd2-d9fc-4813-a81c-93d03ee39092" class="bulleted-list"><li style="list-style-type:disc">Otherwise 200ns because 2 memory access</li></ul><h2 id="02cf3edb-2495-4006-82f1-3a8e15dd2445" class="">Example</h2><ul id="de63535f-f8ba-4a80-acb1-94b12d8fa7c8" class="bulleted-list"><li style="list-style-type:disc">Consider a logical address space of 32 pages of 1024 bytes each, mapped onto a physical memory of 64 frames</li></ul><ul id="e2e4c5ce-8352-4ce9-8401-b23ac726cff7" class="bulleted-list"><li style="list-style-type:disc">Generally frame size = page size?</li></ul><ul id="04a6f82d-8038-447e-99aa-3a072f66fff1" class="bulleted-list"><li style="list-style-type:disc">Page offset - 1KB page → 10bits</li></ul><ul id="861a0fef-334a-48a4-93c0-a49902b0f2b3" class="bulleted-list"><li style="list-style-type:disc">How many bits are there in the logical address → 32 * 1024 → 15 bits or 10 + 5</li></ul><ul id="a50abf63-c767-483f-a6d3-eac34344c24b" class="bulleted-list"><li style="list-style-type:disc">How many bits are there in the physical address → 64 * 1024 →16 bits or 10 + 6</li></ul><h1 id="e33d8841-1a24-4105-889f-23d28aef640e" class="">Memory Protection</h1><ul id="fda918f9-afe9-472e-aae3-3384e8ac02f5" class="bulleted-list"><li style="list-style-type:disc">Memory protection implemented by associating protection bit with each frame to indicate if read only or read write access is allowed</li></ul><ul id="a4200c4f-5ac3-4ad8-82fc-06ad1436c396" class="bulleted-list"><li style="list-style-type:disc">Can also add more bits to indicate page execute only and so on</li></ul><ul id="27d39560-4946-4b7a-bf5e-8e9b9c42bc0c" class="bulleted-list"><li style="list-style-type:disc">Valid-invalid bit attached to each entry in the page table<ul id="30f63a15-a137-4f8b-93df-dcb427bf6afb" class="bulleted-list"><li style="list-style-type:circle">valid indicates that the associated page is in the process’s logical address space and is thus a legal page</li></ul><ul id="c7454041-e9b7-42e4-9e2d-68357ef1d2ec" class="bulleted-list"><li style="list-style-type:circle">invalid indicates that the page is not in the process’s logical address space</li></ul></li></ul><ul id="16b7cee0-b018-4d74-8557-c0276110035f" class="bulleted-list"><li style="list-style-type:disc">Any violations result in a trap to the kernel</li></ul><h1 id="6ac157f4-46d2-436a-96bd-761367cd0152" class="">Page Table Structure</h1><ul id="83af0b39-ec88-41b8-8571-f32f7c9a3db0" class="bulleted-list"><li style="list-style-type:disc">Memory structures for paging can get huge using straight forward methods<ul id="2dbad23f-80ac-4058-a6cf-4d57312ee241" class="bulleted-list"><li style="list-style-type:circle">Cost a lot</li></ul><ul id="fe10a164-e3e6-40a9-a7f9-f414dc5c62ac" class="bulleted-list"><li style="list-style-type:circle">Don’t want to allocate contiguously</li></ul></li></ul><h2 id="24ff3353-8712-4112-ae85-20ff23954f2d" class="">A. Hierarchical Paging</h2><ul id="39595826-6e14-4bb0-9c8d-a183672cb40a" class="bulleted-list"><li style="list-style-type:disc">Break up the logical address space into multiple page tables</li></ul><ul id="c44e57a1-eff2-4363-bef3-720fb6783724" class="bulleted-list"><li style="list-style-type:disc">Two level page table</li></ul><ul id="edb0abb3-90a8-4e12-8490-3c4ed82e1cda" class="bulleted-list"><li style="list-style-type:disc">We then page the page table. Logical Address will become as follows</li></ul><table id="e0c01c74-9c15-4e2e-a131-749c103dc155" class="simple-table"><tbody><tr id="0a71dee7-85c9-4ec2-8621-190f37d25477"><td id="XH^b" class="">p1</td><td id="k}aD" class="">p2</td><td id="]uOE" class="">d</td></tr><tr id="5f13e854-8db4-40ed-92ec-8c1cf945f672"><td id="XH^b" class="">12</td><td id="k}aD" class="">10</td><td id="]uOE" class="">10</td></tr></tbody></table><ul id="5bee73f0-aa46-48dd-bf3d-3e7104947ba3" class="bulleted-list"><li style="list-style-type:disc">p1 is an index into the outer page table and p2 is the displacement within the page of the inner page table</li></ul><figure id="da2d3fc7-aabe-4e16-8923-9565482bd357" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2014.png"><img style="width:576px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2014.png"/></a></figure><h2 id="b0b31fb3-0d9a-433b-a001-d9d2222a5a52" class="">B. Hashed Page Tables</h2><ul id="278b11c0-8b09-47e9-97c2-0b21bc9c7ddc" class="bulleted-list"><li style="list-style-type:disc">The page number is hashed</li></ul><ul id="8c6946e6-bed8-4046-8a54-21b4fec4c04a" class="bulleted-list"><li style="list-style-type:disc">Page table contains a chain of elements hashing to the same location</li></ul><ul id="7235ab81-c26b-4fcf-868c-613d730427a6" class="bulleted-list"><li style="list-style-type:disc">Each element contains 1 page number, value of the mapped page frame, a pointer to the next element</li></ul><ul id="345eac9c-1509-4132-9a3b-f27361dd0b75" class="bulleted-list"><li style="list-style-type:disc">Page numbers are compared in this chain search for a match</li></ul><ul id="0e8ec8ff-9387-4425-9880-138418d10535" class="bulleted-list"><li style="list-style-type:disc">If a match is found, the corresponding physical frame is extracted</li></ul><figure id="126e5006-220b-4174-9936-ebc97f9bc1aa" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2015.png"><img style="width:576px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2015.png"/></a></figure><h2 id="62d9a056-7662-4692-9e0e-72987ef43569" class="">C. Inverted Page Tables</h2><ul id="6d39e471-6368-4812-a668-3ffb849ba7d6" class="bulleted-list"><li style="list-style-type:disc">Track all physical pages - frames</li></ul><ul id="43254d6e-66b7-497f-90a2-e47ee9f2623d" class="bulleted-list"><li style="list-style-type:disc">One entry for each real page of memory</li></ul><ul id="a30e12b5-e8a1-4e3b-ad2e-fbe7b9256f1a" class="bulleted-list"><li style="list-style-type:disc">Entry consists of the virtual address of the page stored in that memory location with information about the process that owns that page</li></ul><figure id="093d3273-691f-4126-bb9b-0325ab3f4463" class="image"><a href="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2016.png"><img style="width:576px" src="Ch%208%20Main%20Memory%20(RAM)%20Management%2088d38d08333f405b867ee9809ab26a4e/Untitled%2016.png"/></a></figure><ul id="0016133a-7934-45a0-b49c-2b038645e098" class="bulleted-list"><li style="list-style-type:disc">We use pid and page number to check in the page table and we get i value which is the frame number</li></ul><ul id="0ed6ec3b-e0f2-4573-b715-6a0b7c5b70e8" class="bulleted-list"><li style="list-style-type:disc">You save space but the search time goes up</li></ul></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>